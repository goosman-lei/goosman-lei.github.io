---
layout: post
title: [翻译][php扩展开发和嵌入式]第5章-您的第一个扩展
date: 2013-02-16 02:26:00
categories: [php扩展开发, php扩展, php模块开发, php源代码, php内核]
tags: []
---


**全部翻译内容pdf文档下载地址: [http://download.csdn.net/detail/lgg201/5107012](http://download.csdn.net/detail/lgg201/5107012)**
本书目前在github上由laruence(http://www.laruence.com)和walu(http://www.walu.cc)两位大牛组织翻译. 该翻译项目地址为: https://github.com/walu/phpbook
原书名: <Extending and Embedding PHP>
原作者: Sara Golemon
译者: goosman.lei(雷果国)
译者Email: lgg860911@yahoo.com.cn
译者Blog: http://blog.csdn.net/lgg201
**你的第一个扩展**
每一个php扩展的构建至少需要两个文件: 一个configuration文件, 它告诉编译期要构建哪些文件以及需要什么外部的库, 还需要至少一个源文件, 它执行实际的工作.
**剖析扩展**
实际上, 通常会有第二个或第三个配置文件, 以及一个或多个头文件. 对于你的第一个扩展, 你需要添加每种类型的一个文件并使用它们工作.
**配置文件**
要开始了, 首先在你的php源代码目录树的ext/目录下创建名为sample的目录. 实际上这个新的目录可以放在任何地方, 但是为了在本章后面演示win32和静态构建选项, 我们还是先建立在源代码目录下吧.
下一步, 进入这个目录, 创建一个名为config.m4的文件, 键入下面内容:

```cpp
PHP_ARG_ENABLE(sample,
  [Whether to enable the "sample" extension],
  [  enable-sample        Enable "sample" extension support])

if test $PHP_SAMPLE != "no"; then
  PHP_SUBST(SAMPLE_SHARED_LIBADD)
  PHP_NEW_EXTENSION(sample, sample.c, $ext_shared)
fi
```
这是./configure时能够调用enable-sample选项的最低要求.PHP_ARG_ENABLE的第二个参数将在./configure处理过程中到达这个扩展的配置文件时显示. 第三个参数将在终端用户执行./configure --help时显示为帮助信息.
*有没有想过为什么有的扩展配置使用enable-extname, 而有的扩展则使用with-extname? 功能上两者没有区别. 实际上, enable表示启用这个特性不需要其他任何第三方库, 相比之下, with则表示要使用这个特性还有其他先决条件*
*现在, 你的sample扩展并不需要和其他库链接, 因此只需要使用enable版本. 在第17章"外部库"中, 我们将介绍使用with并指示编译器使用额外的CFLAGS和LDFLAGS设置.*
如果终端用户使用enable-sample选项调用了./configure, 那么本地的环境变量$PHP_SAMPLE, 将被设置为yes. PHP_SUBST()是标准autoconf的AC_SUBST()宏的php修改版, 它在将扩展构建为共享模块时需要.
最后但并不是不重要的, PHP_NEW_EXTENSION()定义了模块并枚举了所有必须作为扩展的一部分编译的源文件. 如果需要多个文件, 它可以在第二个参数中使用空格分隔列举, 例如:

```cpp
PHP_NEW_EXTENSION(sample, sample.c sample2.c sample3.c, $ext_shared)

```
最后一个参数是对应于PHP_SUBST(SAMPLE_SHARED_LIBADD)命令的, 在构建共享模块的时候同样需要它.
**头文件**
当使用C开发的时候, 将数据的类型定义放到外部的头文件中隔离起来, 由源文件包含是常见的做法. 尽管php并不要求这样, 但是这样做在模块增长到不能放到单个源文件时是有简化作用的.
在你的php_sample.h头文件中, 以下面内容开始:

```cpp
#ifndef PHP_SAMPLE_H
/* 防止重复包含 */
#define PHP_SAMPLE_H

/* 定义扩展的属性 */
#define PHP_SAMPLE_EXTNAME    "sample"
#define PHP_SAMPLE_EXTVER    "1.0"

/* 在php源码树外面构建时引入配置选项 */
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

/* 包含php的标准头文件 */
#include "php.h"

/* 定义入口点符号, Zend在加载这个模块的时候使用 */
extern zend_module_entry sample_module_entry;
#define phpext_sample_ptr &sample_module_entry

#endif /* PHP_SAMPLE_H */
```
这个头文件完成了两个主要的任务: 如果扩展使用phpize工具构建(本书通常都使用这种方式), 那么HAVE_CONFG_H就是已定义的, 这样config.h就会被正常的包含进来. 无论扩展怎样编译, 都会从php源码树中包含php.h. 这个头文件中包含了php源码中访问大部分PHPAPI要使用的其他头文件.
接下来, 你的扩展使用的zend_module_entry结构定义为外部的, 这样当这个模块使用extension=xxx加载时, 就可以被Zend使用dlopen和dlsym()取到.
*译注: 关于模块的加载过程, 请参考译者的一篇博客<*从dl('xxx.so');函数分析PHP模块开发*>(http://blog.csdn.net/lgg201/article/details/6584095)*
头文件中还会包含一些预处理, 定义将在原文件中使用的信息.
**源代码**
最后, 最重要的你需要在sample.c中创建一个简单的源码骨架:

```cpp
#include "php_sample.h"

zend_module_entry sample_module_entry = {
#if ZEND_MODULE_API_NO >= 20010901
     STANDARD_MODULE_HEADER,
#endif
    PHP_SAMPLE_EXTNAME,
    NULL, /* Functions */
    NULL, /* MINIT */
    NULL, /* MSHUTDOWN */
    NULL, /* RINIT */
    NULL, /* RSHUTDOWN */
    NULL, /* MINFO */
#if ZEND_MODULE_API_NO >= 20010901
    PHP_SAMPLE_EXTVER,
#endif
    STANDARD_MODULE_PROPERTIES
};

#ifdef COMPILE_DL_SAMPLE
ZEND_GET_MODULE(sample)
#endif
```
就这样简单. 这三个文件是创建一个模块骨架所需的一切.但是, 它没有任何功能, 不过作为你在本节后面填充功能的模板是不错的选择. 不过先让我们看看究竟发生了什么.
开始的一行非常简单, 包含了你刚才创建的头文件, 通过扩展得到了php源码树中的其他内核头文件.
接下来, 创建你在头文件中定义的zend_module_entry结构. 你应该注意到了, zend_module_entry的第一个元素是一个条件表达式, 给予当前的ZEND_MODULE_API_NO定义. 这个API编号大概是php4.2.0的, 如果你确定你的扩展不会安装在比这还古老的版本, 你可以砍掉#ifdef部分, 直接包含STANDARD_MODULE_HEADER元素.
考虑一下, 无论如何, 它都会在编译期耗费一点时间, 而不会对结果产生的二进制或处理需要的时间产生影响, 因此多数情况下最好直接砍掉这个条件. 这同样适用于下面的版本属性.
其他的6个元素现在初始设置为NULL; 你可以在它后面的注释中看到它的用途.
最后, 在最底下你可以看到每个可以编译为共享模块的php扩展都会有的一个公共元素. 这个简短的条件在你动态加载时由Zend增加一个引用. 不要关心它的细节, 你只需要保证它的存在, 否则下一节可能就无法工作了.
**构建你的第一个扩展**
现在你拥有了所有的文件, 是时候编译安装了. 相比编译主php二进制, 步骤上略有不同.
**在*nix上构建**
第一步是使用config.m4中的信息作为末班生成./configure脚本. 这可以运行在你安装主php二进制时附带安装的phpize程序来完成:

```cpp
$ phpize
PHP Api Version: 20041225
Zend Module Api No: 20050617
Zend Extension Api No: 220050617
```
*Zend Extension Api No前面多出来的2并不是印刷错误; 它对应于Zend引擎2这个版本号, 一般认为要保持这个API编号大于它对应的ZE1版本.*
如果你此时查看当前目录 你会注意到比刚才的3个文件多了不少文件. phpize程序结合你扩展的config.m4文件以及从你的php构建中收集的信息和所有让编译发生所需的一切. 这意味着你不用纠缠在makefile和定位php头上面. php已经帮你做了这个工作.
下一步就简单了, 执行./configure. 这里你只要配置你的扩展, 因此你需要做的如下:

```cpp
$ ./configure --enable-sample

```
注意这里没有使用enable-debug和enable-maintainer-zts. 这是因为phpize已经将它们的值从主php构建中拿过来并应用到你的扩展的./configure脚本中了.
现在, 构建它! 和其他任何的包一样, 你只需要键入make, 生成的脚本文件就会处理剩下的事情.
构建处理完成后, 你会得到一个消息指出sample.so已经编译并放在了当前构建目录下一个名为"modules"的目录中.
**在windows上构建**
译者不熟悉windows平台, 因此略过.
**将构建的扩展作为共享模块加载**
在请求的时候为了让php找到这个模块, 需要将它放到php.ini中extension_dir设置的目录下. 默认的php.ini放在/usr/local/lib/php.ini; 不过这个默认值可能会因为包管理系统而不同. 检查php -i的输出可以看到你这个配置文件在哪里.
如果php.ini中的这个设置没有修改过, 它的值默认是"PHP_HOME/lib/php/extensions/debug-zts-20100525", 后面的debug-zts-20100525分别是是否启用调试, 是否启用zts, PHPAPI编号. 如果你还没有已加载的扩展, 或者说除了sample.so没有其他扩展, 可以将这个值修改到你make产生模块的路径. 否则, 直接将产生的sample.so拷贝到这个设置的目录下.(译注:
 php -i | grep extension_dir查找你的extension_dir设置)
在extension_dir指向正确的位置后, 有两种方式告诉php去加载你的模块. 第一种是在脚本中使用dl()函数:

```php
<?php
    dl('sample.so');
    var_dump(get_loaded_modules());
?>
```
如果脚本没有显示sample已加载, 则表示有哪里出了问题. 查看输出上面的错误消息作为线索, 或者如果在php.ini中进行了相应的设置就参考error_log.
第二种方式, 也是更常用的方式, 在php.ini中使用extension指令指定要加载的模块. 这个指令在php.ini的设置中是比较特殊的, 可以多次以不同的值使用它. 因此如果你已经在php.ini中设置了一个扩展, 不要在同一行使用分隔符的方式列举, 而是插入新的一行: extension=sample.so. 此时你的php.ini看起来是这样的:

```cpp
extension_dir=/usr/local/lib/php/modules/
extension=sample.so
```
现在你可以不使用dl()运行相同的脚本, 或者直接执行php -m命令, 就可以在已加载模块列表中看到sample了.
*所有本章剩余以及以后章节的代码, 都假设你已经按照这里描述的方法加载了当前扩展. 如果你计划使用dl(), 请确认在测试脚本中加入加载的代码(dl()).*
**静态构建**
在已加载模块列表中, 你可能注意到了一些在php.ini中并没有使用extension指令包含的模块. 这些模块是直接构建到php中的, 它们作为主php程序的一部分被编译进php中.
**在*nix下静态构建**
现在, 如果你现在进入到php源码树的根目录, 运行./configure --help, 你会看到虽然你的扩展和所有其他模块都在ext/目录下, 但它并没有作为一个选项列出. 这是因为, 此刻, ./configure脚本已经生成了, 而你的扩展并不知道. 要重新生成./configure并让它找到你的新扩展, 你需要做的只是执行一条命令:

```cpp
$ ./buildconf

```
*如果你使用产品发布版的php做开发, 你会发现./buildconf自己不能工作. 这种情况下, 你需要执行: ./buildconf --force来绕过对./configure命令的一些保护.*
现在你执行./configure --help就可以看到--enable-sample是一个可用选项了. 此时, 你就可以重新执行./configure, 使用你原来构建主php时使用的所有选项, 外加--enable-sample, 这样构建出来的php二进制文件就是完整的, 包含你自己扩展的程序.
当然, 这样做还有点早. 你的扩展除了占用空间还应该做一些事情.
**windows下静态构建**
译者不熟悉windows环境, 因此略过.
**功能函数**
在用户空间和扩展代码之间最快捷的链接就是PHP_FUNCTION(). 首先在你的sample.c文件顶部, #include "php_sample.h"之后增加下面代码:

```cpp
PHP_FUNCTION(sample_hello_world)
{
    php_printf("Hello World!\n");
}
```
PHP_FUNCTION()宏函数就像一个普通的C函数定义, 因为它按照下面方式展开:

```cpp
#define PHP_FUNCTION(name) \
    void zif_##name(INTERNAL_FUNCTION_PARAMETERS)
```
这种情况下, 它就等价于:


```cpp
void zif_sample_hello_world(zval *return_value,
    char return_value_used, zval *this_ptr TSRMLS_DC)
```

当然, 只定义函数还不够. 引擎需要知道函数的地址以及应该暴露给用户空间的函数名. 这通过下一个代码块完成, 你需要在PHP_FUNCTION()块后面增加:

```cpp
static function_entry php_sample_functions[] = {
    PHP_FE(sample_hello_world,        NULL)
    { NULL, NULL, NULL }
};
```
php_sample_functions向量是一个简单的NULL结束向量, 它会随着你向扩展中增加功能而变大. 每个你要暴露出去的函数都需要在这个向量中给出说明. 展开PHP_FE()宏如下:

```cpp
{ "sample_hello_world", zif_sample_hello_world, NULL},

```
这样提供了新函数的名字, 以及指向它的实现函数的指针. 这里第三个参数用于提供暗示信息, 比如某些参数需要引用传值. 在第7章"接受参数"你将看到这个特性.
现在, 你有了一个要暴露的函数列表, 但是仍然没有连接到引擎. 这通过对sample.c的最后一个修改完成, 将你的sample_module_entry结构体中的NULL, /* Functions */一行用php_sample_functions替换(请确保留下那个逗号).
现在, 通过前面介绍的方式重新构建, 使用php命令行的-r选项进行测试, -r允许你不用创建文件直接在命令行运行简单的代码片段:

```cpp
$ php -r 'sample_hello_world();
```
如果一切OK的话, 你将会看到输出"Hello World!". 恭喜!!!
**Zend内部函数**
内部函数名前缀"zif_"是"Zend内部函数"的命名标准, 它用来避免可能的符号冲突. 比如, 用户空间的strlen()函数并没有实现为void strlen(INTERNAL_FUNCTION_PARAMETERS), 因为它会和C库的strlen冲突.
zif_的前缀也并不能完全避免名字冲突的问题. 因此, php提供了可以使用任意名字定义内部函数的宏: PHP_NAMED_FUNCTION(); 例如PHP_NAMED_FUNCTION(zif_sample_hello_world)等同于前面使用的PHP_FUNCTION(sample_hello_world)
当使用PHP_NAMED_FUNCTION定义实现时, 在function_entry向量中, 可以对应使用PHP_NAMED_FE()宏. 因此, 如果你定义了自己的函数PHP_NAMED_FUNCTION(purplefunc), 就要使用PHP_NAMED_FE(sample_hello_world, purplefunc, NULL), 而不是使用PHP_FE(sample_hello_world, NULL).
我们可以在ext/standard/file.c中查看fopen()函数的实现, 它实际上使用PHP_NAMED_FUNCTION(php_if_fopen)定义.从用户空间角度来看, 它并不关心函数是什么东西, 只是简单的调用fopen(). 
**函数别名**
有时一个函数可能会有不止一个名字. 回想一下, 普通的函数内部定义是用户空间函数名加上zif_前缀, 我们可以看到用PHP_NAMED_FE()宏可以很容易的创建这个可选映射.

```cpp
PHP_FE(sample_hello_world,    NULL)
PHP_NAMED_FE(sample_hi,    zif_sample_hello_world,     NULL)
```
PHP_FE()宏将用户空间函数名sample_hello_world和PHP_FUNCTION(sample_hello_world)展开而来的zif_sample_hello_world关联起来. PHP_NAMED_FE()宏则将用户空间函数名sample_hi和同一个内部实现关联起来.
现在, 假设Zend引擎发生了一个大的变更, 内部函数的前缀从zif_修改为pif_了. 这个时候, 你的扩展就不能工作了, 因为当到达PHP_NAMED_FE()时, 发现zif_sample_hello_world没有定义.
这种情况并不常见, 但非常麻烦, 可以使用PHP_FNAME()宏展开sample_hello_world避免这个问题:


```cpp
PHP_NAMED_FE(sample_hi, PHP_FNAME(sample_hello_world), NULL)
```

这种情况下, 即便函数前缀被修改, 扩展的zend_function_entry也会使用宏扩展自动的更新.
现在, 你这样做已经可以工作了, 但是我们已经不需要这样做了. php暴露了另外一个宏, 专门设计用于创建函数别名. 前面的例子可以如下重写:

```cpp
PHP_FALIAS(sample_hi, sample_hello_world, NULL)
```
实际上这是官方的创建函数别名的方法, 在php源码树中你时常会看到它.
**小结**
本章你创建了一个简单的可工作的php扩展, 并学习了在主要平台上构建它需要的步骤. 在以后的章节中, 你将会继续丰满这个扩展, 最终让它包含php的所有特性.
php源码树和它编译/构建在各个平台上依赖的工具经常会发生变化, 如果本章介绍的某些地方不能正常工作, 请参考php.net在线手册的Installation一掌, 查看你使用的版本的特殊需求.


[目录](http://blog.csdn.net/lgg201/article/details/8493725)上一章:[安装构建环境](http://blog.csdn.net/lgg201/article/details/8568578)
下一章:[返回值](http://blog.csdn.net/lgg201/article/details/8618600)
