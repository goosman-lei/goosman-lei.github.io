---
layout: post
title: struts2的请求处理过程源码分析
date: 2010-01-24 19:51:00
categories: [struts, action, url, 存储]
tags: []
---
1. struts2分发的请求处理过程:
1.1. org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter.doFilter()方法中:
1.1.1. 设置编码和本地化信息
1.1.2. 创建ActionContext对象
1.1.3. 分配当前线程的分发器
1.1.4. 将request对象进行封装
1.1.5. 获取ActionMapping对象, ActionMapping对象对应一个action详细配置信息
1.1.6. 执行Action请求, 进入下面方法
1.2. org.apache.struts2.dispatcher.Dispatcher.serviceAction()方法:
1.2.1. 首先获取当前请求是否已经有valueStack对象, 这样做的目的是在接受到chain跳转方式的请求时, 可以直接接管上次请求的action
1.2.2. 如果请求中没有ValueStack对象, 获取当前线程的ActionContext对象
1.2.3. 从ActionContext中获取ValueStack
1.2.4. 将事先处理好的请求中的参数put到ValueStack中
1.2.5. 获取ActionMapping中配置的namespace, name, method值
1.2.6. 根据配置获取当前Action的代理对象ActionProxy(这个过程中会创建Action对象, 同时返回的代理对象是StrutsActionProxy的实例)
1.2.7. 向request中设置ValueStack对象
1.2.8. 进入ActionProxy的处理
1.3. org.apache.struts2.impl.StrutsActionProxy.execute()方法:
1.3.1. 准备上下文环境
1.3.2. StrutsActionProxy是继承自com.opensymphony.xwork2.DefaultActionProxy的, 在这个代理对象内部实际上就持有了com.opensymphony.xwork2.DefaultActionInvocation的一个实例的
1.3.3. DefaultActionInvocation对象中保存了Action调用过程中需要的一切信息
1.3.4. 此时, 调用它的invoke方法
1.4. com.opensymphony.xwork2.DefaultActionInvocation.invoke()方法:
1.4.1. 首先会顺序的递归执行当前Action中所配置的所有的拦截器, **直到拦截器遍历完毕调用真正的Action**
1.4.2. 通过调用DefaultActionInvocation的invokeActionOnly()方法去反射调用Action, 调用过程中, 会从当前的invocation对象中得到Action的实例, 并通过代理对象获得配置信息.
1.5. com.opensymphony.xwork2.DefaultActionInvocation.invokeAction()方法:
1.5.1. 反射获得当前请求分发的Action中的方法对象
1.5.2. 以传入的Action实例反射调用该处理方法
1.5.3. 如果返回的结果不是com.opensymphony.xwork2.Result的实例, 返回强转为字符串的结果.
1.6. 回到1.4所在方法继续:
1.6.1. 将invokeAction返回的resultCode存储到当前的invokeAction实例中
1.6.2. 进入result处理
1.7. com.opensymphony.xwork2.DefaultActionInvocation.executeResult()方法:
1.7.1. 创建result对象(com.opensymphony.xwork2.DefaultActionInvocation.createResult()方法)
1.7.1.1. 如果当时调用Action返回了Result对象, 则直接返回
1.7.1.2. 否则, 通过proxy对象获取配置信息, 根据resultCode获取到Result对象
1.7.2. 使用ognl翻译result中的用${}和%{}标识引用ValueStack中的值的参数.
1.7.3. 调用执行result
1.8. org.apache.struts2.dispatcher.ServletDispatcherResult.doExecute()方法
1.8.1. 准备执行环境: request, pageContext等等
1.8.2. 判断有没有合适的分发器, 如果没有, 发404消息
1.8.3. 在request对象中设定两个属性:
1.8.3.1. struts.view_uri: 分发之后的url地址
1.8.3.2. struts.request_uri: 真正请求的url地址
1.8.4. 发送真正的响应信息
 1.9. 至此, Action的处理完毕, 回归到1.4.1中指明的递归调用那里, 逐步的返回并执行每个拦截器的invokeAction.invoke()后面的代码, 从这里也就可以看出拦截器的机制.
