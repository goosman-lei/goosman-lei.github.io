---
layout: post
title: python 核心编程学习笔记(第4章) 对应Let's-python视频第5集
date: 2009-10-24 09:56:00
categories: [python, 编程, 存储, types, object, list]
tags: []
---
#python对象(chapter4)
1 python对象有三个特征: 身份和类型是只读的, 如果对象支持不支持更新操作, 那么值也就是只读的.
1.1 身份: 唯一的身份标识, 可以使用内建函数id()得到, 可以看作是对象的内存地址…
1.2 类型: 对象的类型决定该对象保存什么类型的值, 可以进行什么操作, 遵循什么规则., 可以使用内建函数type()查看python对象的类型.
1.3 值: 对象表示的数据项
2 对象属性: 主要有属性, 值, 相关联的可执行代码(method), 一些python类型也有数据属性, 含有数据属性的对象包括但不限于: 类, 类实例, 模块, 复数, 文件.
3 基础数据类型: 数字, 整形, 布尔型, 长整型, 浮点型, 复数型, 字符串, 列表, 元组, 字典.
4 其他内建类型: 类型, None, 文件, 集合/固定集合, 函数/方法, 模块, 类
4.1 type(type(1)) 可以看出类型对象本身也是对象, 它的类型是type
4.2 None的类型是NoneType, NoneType只有一个值, 就是None, 不支持任何运算也没有任何内建方法, 布尔值总返回False
5 每个对象天生都有布尔值, 以下对象的布尔值是False
5.1 None
5.2 False(bool类型)
5.3 所有值为0的数
5.4 ‘’ 空字符串
5.5 [] | () | {} 空列表, 空元组, 空字典
5.6 用户创建的实例如果定义了nonzero(__nonzero__())或length(__len__())且值为0, 那么返回的布尔值也是False
6 当要获取一个对象的布尔值的时候, 首先会调用__nonzero__(必须返回布尔类型或者int类型.)方法, 如果实现了该方法, 就返回该方法返回的布尔值, 如果没有实现该方法, 继续调用__len__方法(该方法返回值必须是大于等于0的), 如果实现了__len__方法, 就根据其返回值返回布尔值.  
7 内部类型: python内部机制
7.1 代码: 编译过的python的源代码片段, 是可执行对象. 通过调用内建函数compile()可以得到代码对象. 代码对象可以被exec命令或eval()内建函数来执行.   代码是用户自定义函数的核心, 运行期获得上下文..  __code__是函数的一个属性, 函数除了代码这个属性, 还有函数名, 文档字符串, 默认参数, 全局命名空间等必须的属性
7.2 帧对象: 用于跟踪记录对象
7.3 跟踪记录: 用于异常发生时, 程序访问跟踪记录对象处理程序.
7.4 切片: 
7.4.1 步进切片sequence[::number] number为负数, 倒序显示字符串, 正数则正序显示字符串, 数值代表显示字符的step值.   
7.4.2  多维切片 sequence[start1: end1, start2: end2]
7.4.3  省略切片sequence[…, start1: end1]
7.4.4 切片对象使用slice([start, ]stop[, step])可以创建一个切片对象
7.5 省略对象: 用于扩展切片语法, 起记号作用..在切片语法中表示省略号, 省略对象有一个唯一的名字Ellipsis, 布尔值始终是True
7.6 Xrange: 调用xrange()生成Xrange对象, 类似内建函数range, 用于节省内存使用或range无法完成的超大数据集场合
8 标准类型运算符
8.1 对象值比较
8.1.1 数字根据大小比较
8.1.2 字符串根据字符先后顺序比较
8.1.3 list | tuple | dict顺序按照其中元素(dict按照键)比较
8.1.4 链式比较相当于多个比较使用and连接
8.1.5 自定义类型对象的比较是引用值比较, 也就是id(object_name)的比较
8.2 对象身份比较
8.2.1 is / is not用来比较两个别名是否引用同一个对象
8.2.2 证书对象和字符串对象是不可变对象…
8.3 布尔类型运算符: and, or, not
9 标准类型内建函数
9.1 cmp(obj1, obj2)  比较obj1和obj2, 根据比较结果返回整数i, i<0 à obj1<obj2, i>0 à obj1>obj2, i==0 à obj1 == obj2….自定义类型中通过定义方法__cmp__(target)来实现….使用比较运算符, 或直接调用cmp时该方法被调用
9.2 type(obj)  得到一个对象的类型, 返回相应的type对象
9.3 str(obj)  返回对象适合可读性好的字符串表示…在自定义类中使用__str__(self)返回一个字符串, 调用str(obj)时会被隐式调用
9.4 repr(obj)  返回一个对象的字符串表示, repr返回的字符串通常可以被用于使用eval动态创建一个对象.  通常 obj == eval(repr(obj))是成立的
9.5 ``, 反单引号, `obj`和repr(obj)做的事情是一样的.
9.6 isinstance(obj, (type[, type, …]))  判断obj是不是第二个参数tuple中的列举的类型的实例
9.7 types模块提供一些已知的类型
9.8 由于每一种类型都只有一个类型对象, 所以, 可以使用引用比较代替值比较以提升性能: 用if type(num) is types.IntType 替代if type(num) == types.IntType
9.9 from-import: 只引入某个模块的一部分属性: 比如from types import IntType 这样做可以有效的减少查询次数
9.10 python的operator模块中有绝大多数运算符对应的同功能的函数可供使用.
10 类型工厂函数: int(), long(), float(), complex(), str(), Unicode(), basestring(), list(), tuple(), type(), dict(), bool(), set(), frozenset(), object(), classmethod(), staticmethod(), super(), property(), file()
11 标准类型的分类:
11.1 标准类型是”基本内建数据对象原始类型”
11.1.1 基本: 是python的标准或核心
11.1.2 内建: python默认提供
11.1.3 数据: 用于一般数据存储
11.1.4 对象: 对象是数据和功能的默认抽象
11.1.5 原始: 这些类型提供的是最底层的粒度数据存储
11.1.6 类型: 本身就是数据类型
11.2 按存储模型进行分类: 
11.2.1 标量/原子类型: 数值, 字符串等可以存储单一字面对象的类型.
11.2.2 容器类型: 列表, 元素, 字典等可以存储多个字面变量的类型, python中的容器类型都可以存储不同类型的元素
11.3 按更新模型进行分类:  对象创建之后, 值不可以改变, 注意: 这里是对象, 而不是变量
11.3.1 可变类型: 列表, 字典
11.3.2 不可变类型: 数字, 字符串, 元组
11.4 按访问模型进行分类: 访问对象的方式
11.4.1 直接访问: 数值
11.4.2 顺序访问: 列表, 元组, 字符串等可以按照索引访问的类型
11.4.3 映射访问: 字典
不支持的类型: char, byte, pointer
