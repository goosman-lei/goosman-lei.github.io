---
layout: post
title: python的闭包(3.0之前及之后)
date: 2010-02-08 01:58:00
categories: [python, windows, 编程, list, 测试, 平台]
tags: []
---
首先, 说说python里面的闭包吧:
1. 需要函数嵌套, 就是一个函数里面再写一个函数.
2. 外部函数需要返回一个内部函数的引用
3. 外部函数中有一些局部变量, 并且, 这些局部变量在内部函数中有使用
概念:
1. 自由变量: 外部函数中定义的局部变量, 并且在内部函数中被使用.
2. 闭包: 那个使用了自由变量并被返回的内部函数就称为闭包.
一个例子:(来自<python核心编程>)

```python
def counter(start_at=0): 
    count = [start_at] 
    def incr():
        count[0] += 1
        return count[0]
    return incr
```

问题的提出:[关于python闭包的一个问题](http://topic.csdn.net/u/20100207/16/9486bdda-cf31-4e4d-8486-957477a2d6c2.html?seed=59820191&r=63332596#r_63332596) , 呵呵, 论坛一位网友提出的问题: 自由变量只能是list吗?
 
 

```python
def f():
   a = [1, 2]
   b = 1
   c = 'hello'
   d = (1, )
   e = True
   f = {1: 2}

   def inf():
      print locals()
      a[0] += 1
      b = 2
      c = 3
      d = (2, )
      e = False
      f[1] = 3
      return a[0]
   return inf

a = f()
t = a()
print t
```
 
 
上面这一段代码中, 内部函数inf第一句打印了locals(), 最终打印的结果只有a和f, 这段代码我的测试环境是python2.5, windows平台...对于这段, 我总结:
1. 内部函数中, 遇到一个变量, 如果是试图改变它的子元素(集合类型)或自己名称空间(比如函数作为变量或对象作为变量时, 自己同时是名称空间)内部其他名称的引用时, 将会合法的引用到外部变量.
2. 内部函数中, 遇到一个变量, 如果试图直接改变其自身, 多数情况都会得到"使用前未指定"的错误, 请看原因:

```python
def f():
   a = 1
   def inf():
      a += 1
      return a
   return inf
```

最重要的就在a+=1这一句, 这里, python实际上会认为你是在创建一个新的本地变量并为他赋值, 也就是说, python的解释器认为a+=1是a = a + 1, 而此时就很明显了, 本地变量中目前没有a, 所以, 就得到了我们上面说的那个错误...
3. 通常需要在闭包内部去修改外部函数变量的时候, 我们需要借助一些集合类型或有名称空间的对象进行操作.
 
以上这部分都是python3.0之前的情况, 在3.0之后, 加入了一个新的关键字nonlocal, 就像当初的global关键字解决函数内修改全局变量的问题一样漂亮, nonlocal将闭包内修改外部变量的问题也很优美的搞定了.

```python
def f():
   a1 = 'hello'
   a2 = 1
   a3 = o()
   a3.x = 1
   def inf():
      print(locals())
      nonlocal a2, a1
      a1 += ' world'
      a2 += 2
      a3.x += 1
      return a1, a2, a3
   return inf
```

上面的代码中, 通过在闭包内, 使用外部变量之前, 用nonlocal去声明一下要在闭包中进行修改的那两个变量不是本地变量, 就OK了, 和global的用法完全一致, 这样, 我们就可以在其后的代码段中, 修改普通的外部变量了.....
