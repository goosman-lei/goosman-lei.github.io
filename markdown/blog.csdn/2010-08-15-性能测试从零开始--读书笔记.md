author: selfimpr
blog: http://blog.csdn.net/lgg201
mail: lgg860911@yahoo.com.cn
 
感谢[51testing](http://www.51testing.com)的柳胜前辈精彩的讲解
以下是我的读书笔记, 在公司是程序员, 工作需要, 简单学习一下, 分享出来, 不足之处, 请邮件指点, 谢谢.
 
 
#Vuser脚本语言基础
1 脚本结构:
1.1 vuser_init: 脚本初始化操作, 一般放置登录操作, 分配内存等, 在播放vuser_init时, Controller的Vuser状态区域会显示initialize状态
1.2 Action: 虚拟用户要做的业务操作.
1.3 vuser_end: 与vuser_init对应, 做收尾工作.
2 脚本中使用的三种函数
2.1 VU通用函数: lr_系列函数
2.2 协议相关函数: 一般以协议名开头, 比如web协议就是web_系列
2.3 语言相关函数: 由VU脚本的生成语言决定. 多用于用户自定义函数进行脚本扩展.
3 以C语言的VU脚本为例, 实际上是隐式的存在main函数的, 然后在main中去依次调用了vuser_init, Action, vuser_end几个函数.
4 录制HTTP协议的web系统测试脚本时, 会生成一个globals.h文件, 这个文件用来负责vuser_init,
Action, vuser_end三个脚本都可用的全局变量的声明.
5 lr_whoami(*userid, char
**groupname, int *sceneid)可以用来获取当前运行vuser的vuserid, 组名, 场景id, 在动态参数化的时候, 可以使用这些值来构建动态参数.
6 自定义函数: 
6.1 直接引用: 以C语言产生的脚本, 可以直接在Action外部定义函数, 然后在Action内使用.
6.2 本地加载: 使用lr_load_dll(char *dll_file_name);加载动态链接库, 然后调用库中的函数.
6.3 include模式: 把多个函数写在一个文件中, 在vuser_init,
Action, vuser_end中的include并调用
6.4 全局加载(dll)模式: 在LoadRunnder/data目录下的mdrv.dat文件中, 查找对应协议, 然后在下面按照已有内容格式配置链接库即可
7 通用vu函数: 构建在C语言基础上的脚本框架函数, 以lr开头, 分为以下几类
7.1 事务和事务控制函数: 
7.1.1 lr_end_sub_transaction: 标记子事务的结束以便进行性能分析
7.1.2 lr_end_transaction: 标记LoadRunner事务的结束
7.1.3 lr_end_transaction_instance: 标记事务实例的结束以便进行性能分析
7.1.4 lr_fail_trans_with_error: 打开事务的状态设置为LR_FAIL并发送错误消息.
7.1.5 lr_get_trans_instance_duration: 获取事务实例的持续时间
7.1.6 lr_get_trans_instance_wasted_time:获取事务实例浪费的时间
7.1.7 lr_get_transaction_duration: 获取事务的持续事件(按事务名称)
7.1.8 lr_get_transaction_think_time: 获取事务的思考时间(按事务名称)
7.1.9 lr_get_transaction_wasted_time: 获取事务浪费的时间(按事务的名称)
7.1.10 lr_resume_transaction: 继续收集事务数据以便进行性能分析
7.1.11 lr_resume_transaction_instance: 继续收集事务实例数据以便进行性能分析
7.1.12 lr_set_transaction_instance_status:设置事务实例的状态
7.1.13 lr_set_transaction_status: 设置打开事务的状态
7.1.14 lr_set_transaction_status_by_name:设置事务的状态
7.1.15 lr_start_sub_transaction: 标记子事务的开始
7.1.16 lr_start_transaction: 标记事务的开始
7.1.17 lr_start_transaction_instance: 启动嵌套事务(由它的父事务的句柄指定)
7.1.18 lr_stop_transaction: 停止事务数据的收集
7.1.19 lr_stop_transaction_instance: 停止事务实例的数据收集
7.1.20 lr_wasted_time: 消除所有打开事务浪费的时间.
7.2 命令行分析函数: 当LoadRunner以命令行方式启动和运行时, 以下函数用来分析命令行
7.2.1 lr_get_attrib_double: 检索脚本命令行中使用的double类型变量
7.2.2 lr_get_attrib_long: 检索脚本命令行中使用的long行变量
7.2.3 lr_get_attrib_string: 检索脚本命令行中使用的字符串
7.3 系统信息函数: 获取VU的系统信息
7.3.1 lr_user_data_point: 记录用户定义的数据采集点
7.3.2 lr_whoami: 将有关vuser的信息返回给vuser脚本
7.3.3 lr_get_host_name: 返回执行vuser脚本的主机名
7.3.4 lr_get_master_host_name: 返回运行LoadRunner Controller的计算机名
7.4 字符串函数:
7.4.1 lr_eval_string: 返回参数的当前值
7.4.2 lr_save_string: 将以NULL结尾的字符串保存到参数中
7.4.3 lr_save_var: 将变长字符串保存到参数中
7.4.4 lr_save_datetime: 将当前日期和时间保存到参数中
7.4.5 lr_advance_param: 前进到下一个可用参数
7.4.6 lr_decrypt: 解密已编码的字符串
7.4.7 lr_eval_string_ext: lr_eval_string的扩展, 为指向包含参数数据的缓冲区的指针
7.4.8 lr_eval_string_ext_free: 释放由lr_eval_string_ext分配的指针
7.4.9 lr_save_searched_string: 在缓冲区中搜索字符串实例, 并将该字符串实例保存到参数中.
7.5 消息函数:
7.5.1 lr_debug_message: 将调试信息发送到输出窗口
7.5.2 lr_error_message: 将错误消息发送到输出窗口
7.5.3 lr_get_debug_message: 得到当前的消息类
7.5.4 lr_log_message: 将输出消息直接发送到output.txt文件, 此文件位于vuser脚本目录
7.5.5 lr_output_message: 将消息发送到输出窗口中
7.5.6 lr_set_debug_message: 为输出消息设置消息类
7.5.7 lr_vuser_status_message: 生成格式化输出并将其打印到Controller Vuser状态区域
7.5.8 lr_message: 将消息发送到vuser日志和输出窗口.
7.6 运行时函数:
7.6.1 lr_load_dll: 加载外部dll
7.6.2 lr_think_time: 暂停脚本的执行, 以模拟思考时间
7.6.3 lr_continue_on_error: 指定脚本如何处理错误场景, 是继续还是退出
7.6.4 lr_rendezvous: 在vuser脚本中设置集合点
8 HTTP协议函数:
8.1 HTTP协议:
8.1.1 header设置:
8.1.1.1 web_add_header
8.1.1.2 web_clean_heander
8.1.2 点击链接:
8.1.2.1 web_link(文字链接)
8.1.2.2 web_image(点击图片链接)
8.1.3 提交表单:
8.1.3.1 web_submit_data
8.1.3.2 web_submit_form
8.2 web系统设置
8.2.1 cache设置:
8.2.1.1 web_cache_leanup
8.2.1.2 web_load_cache
8.2.2 cookie设置
8.2.2.1 web_add_cookie
8.2.2.2 web_cleanup_cookies
8.2.3 proxy设置
8.2.3.1 web_set_proxy
8.2.3.2 web_set_secure_proxy
8.3 LoadRunner框架支持
8.3.1 检查点:
8.3.1.1 web_find
8.3.1.2 web_image_check
8.3.2 关联
8.3.2.1 web_create_html_param
8.3.2.2 web_create_html_param_ex
8.3.2.3 web_reg_save_param
8.3.2.4 web_set_max_html_param_len
8.3.3 控制
8.3.3.1 lr_start_transaction
8.3.3.2 lr_rendezvous
8.3.3.3 lr_think_time
#用户行为模拟器—VUSER
1 录制HTTP协议的脚本时, 录制方式的选择原则:
1.1 基于浏览器的应用程序使用HTML-basedScript
1.2 不是浏览器的应用使用URL-based Script
1.3 如果基于浏览器的应用程序中包含了Javascript并且该脚本向服务器产生了请求,比如DataGrid的分页按钮等, 也要使用URL-based方式录制
1.4 给予浏览器的应用程序中使用了HTTPS安全协议, 使用URL-based方式录制.
2 几种有用的日志: 脚本能够正常运行后, 应当禁用日志以降低消耗.
2.1 执行日志: 
2.1.1 脚本运行时产生.
2.1.2 描述Vuser运行时执行的操作
2.1.3 黑色表示标准输出消息, 红色表示标准错误消息, 绿色用引号括起来的文字字符串(例如URL), 蓝色表示事务信息(开始, 结束, 状态, 持续时间);
2.2 录制日志: 在脚本录制过程中产生, 详细描述录制过程中客户端与服务器之间的各种交互动作.
2.3 产生日志: 记录了脚本录制的设置, 网络实践到脚本函数的转换过程.
3 Tools/General Options/Display/Show
browser during replay选中后可以在VU运行时查看浏览器活动, 不过这只是一个不完整的解释器而不是浏览器, 因此一些脚本可能会加载不完全.打开运行时查看器后在运行脚本时就会实时播放动作.
4 关联: 对于一些请求, 需要以前面某次请求服务器响应的数据去作为请求参数, 因此, 不能把这些数据硬编码, 而是以参数的方式提供, 同样, 要使用的前面某次请求响应的数据也要写入到变量中以便使用.
5 录制前自动关联: 在录制脚本之前, 已知寻找需要关联数据和关联的规则, 就可以通过为VU设置规则来让其自动关联.
5.1 内建关联规则: 对于一些常用系统, VU有内建的关联规则, 通过Recording Options/HTTP
Properties/Correlation中启用关联规则, 然后选择相应的关联规则, 则在录制对应的系统时, 就会自动建立关联.
5.2 自定义关联规则: Recording Options/HTTP Properties/Correlation中建立新的关联规则(也需要启用关联)
6 录制后自动关联: 录制完成后, 脚本至少需要执行一次, 在执行中, 录制后关联会试图找出录制时和执行时服务器响应内容的差异部分, 藉以找出需要关联的数据并建立关联.
7 手动关联: 
7.1 找出需要关联的数据
7.1.1 使用相同的业务流程和数据, 录制两份脚本
7.1.2 使用WinDiff工具找出不同点: Tools/Compare with Vuser
7.2 使用web_reg_save_param函数手动建立关联
7.3 web_reg_save_param函数放在要检查内容的请求之前
7.4 原理: 捕获第一个操作的输出 à保存为参数  à 将参数作为另一个操作的输入
8 关联的用户和意义:
8.1 简化和优化脚本代码
8.2 动态生成数据: session等服务器端返回数据的利用
8.3 支持唯一数据
9 除了显式的以lr_start_transaction控制事务外, 还可以在vuser的运行时设置中的miscellaneous选项中定义自动事务.
10 集合点(同步点): 为了模拟较重的用户负载, 需要模拟多个vuser同时向服务器发送请求, 此时, 就可以在vuser脚本中通过lr_rendezvous来创建集合点, Controller在遇到集合点时会暂停脚本, 等待其他vuser到达后, 一起释放vuser运行.  需要注意的是只能在action中添加集合点, 而不能在vuser_init和vuser_end中创建.
11 思考时间: 为了模拟用户在操作过程中的停顿, 可以用lr_think_time来设置思考时间, 思考时间的单位是秒. 有时测试不需要思考时间, 这时就可以通过Run-time Settings/Think time中设置忽略思考时间.
12 由于集合点和思考时间在Controller运行中都会产生等待, 因此如果在事务中有这两项操作, 就可能会对事务的响应时间产生影响导致结果不准确.
13 参数化的过程:
13.1 在脚本中用参数取代常量值
13.2 设置参数的属性以及数据源.
14 参数数据源类型: 参数的信息在脚本目录下的”脚本名.prm”文件中
14.1 Data Files: 数据保存在文件中
14.2 User-Defined Functions: 调用外部dll函数生成数据
14.3 Internal Data: 虚拟用户内部产生的数据
14.3.1 Date/Time: 用当前日期/时间替换参数, 需要指定Date/Time格式.
14.3.2 Group Name: 用虚拟用户组名称替换参数
14.3.3 Load Generator Name: 用脚本负载生成器的名称替换参数, 负载生成器是虚拟用户在运行的计算机
14.3.4 Iteration Number: 用当前迭代数目替换参数
14.3.5 Random Number: 用一个随机数替换参数
14.3.6 Unique Number: 用一个唯一的数字来替换参数.
14.3.7 Vuser Id: 用运行时分配给Vuser的id替换参数
15 Tools/General
Options/Parameterization可以定义参数的括号类型.
16 直接的参数化, 只有在其作为函数参数时才能够使用, 而且, 有些函数的有些参数是不能被参数化的, 在这种情况下, 如果想要参数化, 可以使用lr_eval_string()来代替要参数化的内容, 而我们去参数化lr_eval_string()的参数.
17 由于lr_eval_string返回的是一个指向参数值的指针, 内容在每次Iteration后自动释放, 因此, 对于一个大的Iteration,如果使用lr_eval_string做参数化可能导致内存迟迟不能释放, 此时可以使用lr_eval_string_ext和lr_eval_string_ext_free配对使用来自己做清理工作.
18 Vuser/Parameter List中可以统一管理当前脚本中所有参数的属性.
19 参数的update value on意义
19.1 each occurrence: 每发生一次换一个
19.2 each iteration: 每次迭代换一个
19.3 once: 所有循环中都使用同一个值
20 参数的when out of values的意义
20.1 Abort Vuser: 中止
20.2 Continue in a cyclick manner: 继续循环取值
20.3 Continue with last value: 取最后一个值
21 从数据库导入参数
21.1 利用Microsoft Query从已存在的数据库中导入参数数据(Microsoft Query是Office的套件之一, 没有安装开始菜单中的快捷方式,可以在Office安装目录下找MSQRY32.EXE,如果没有, 可能是安装Office时没有安装, 运行安装程序添加组件即可)
21.2 指定数据库连接或SQL: 在设置参数的界面如下顺序操作
21.2.1 点击Data wizard
21.2.2 选择Specify SQL statement manually
21.2.3 Creat
21.2.4 新建数据源, 导入数据即可
22 检查点: 对于web应用, vuser中的请求执行成功并不能代表业务流程是成功的, 比如用户名密码错误也会返回200响应, 所以, 需要检查服务器的响应内容来判断业务流程是否执行成功, 这个判断的点就是检查点.
22.1 全局检查点: 运行时设置中设置ContentCheck, 这种检查点对于有统一出错处理页面的系统是有效的. 
22.2 检查函数: 在一个请求完成后, 运行检查函数, 然后作出期望的处理返回.
22.2.1 web_find: 检查文本
22.2.2 web_image_check: 检查图片
22.2.3 web_reg_find: 与web_find类似, 不过, 这个函数是先注册(在请求之前), 然后查找, 并且, 这个函数可以查找多次, 通过SaveCount保存查找到的次数.  另外, 通过运行时设置设置的enable image and text check对web_find有效, 而对web_reg_find无效, 即web_reg_find只要写了就会查找.
23 Action/Import Action into vuser可以将其他Action引入进来
24 在Run-time settings中可以设置脚本的全局错误处理机制(是否继续执行), 但是, 对于某些特殊段的脚本如果期望得到特殊的效果, 可以通过lr_continue_on_error函数来控制, 该函数接受参数0或1, 0表示以下代码在发生错误时退出, 反之则继续执行.
25 动态运行: Tools/General Options/Replay中设置动态运行的延时, 然后在view菜单内选择Animated run即可以进入动态运行状态, 此时运行脚本每运行一句都会暂停设定的毫秒数.
26 扩展日志选项的意义:
26.1 参数替换: 记录指定给脚本的所有参数及其相应的值
26.2 服务器返回的数据: 记录服务器返回的所有数据
26.3 高级跟踪: 记录vuser在会话期间发送的所有函数和消息.
27 由于扩展日志内容较大, 因此可以选择性的开启, 以自定义函数方式, 调用处理时同错误处理一样.
void
ud_log_extend(int switch) {
         lr_set_debug_message(LR_MSG_CLASS_EXTENDED_LOG,
switch); //设置扩展日志
         lr_set_debug_message(LR_MSG_CLASS_PARAMETERS_LOG,
switch); //设置参数替换日志
         lr_set_debug_message(LR_MSG_CLASS_RESULT_LOG,
switch); //设置服务器返回数据日志
         lr_set_debug_message(LR_MSG_CLASS_FULL_LOG,
switch); //设置高级跟踪日志
}
Action_test{
         ud_log_extend(1); /*开启扩展日志*/
         web_link(“test”, “Text=test”, LAST);
         ud_log_extend(0); /*关闭扩展日志*/
         return 0;
}
28 验证测试脚本的通常流程:
28.1 录制或开发脚本
28.2 单用户单迭代: 解决可能存在的关联问题
28.3 单用户多迭代: 验证参数化问题
28.4 多用户单迭代: 验证可能存在的多线程问题
28.5 多用户多线程: 实际就是真正的性能测试开始.
29 Tools/Create Controller Scenario根据当前脚本创建场景
#性能测试指挥中心—Controller
1 手工场景: 负载测试通常使用手工场景, 首先设置虚拟用户数目, 脚本, 以及它们运行的方式, 然后运行得出服务器的响应时间等指标.
2 面向目标的场景: 首先定义测试要达到的目标, 然后LoadRunner自动基于这些目标创建场景, 运行过程中, 不断把结果和目标相比较决定下一步走向.
3 虚拟用户组: 一组用户指的就是针对同一个脚本的多个虚拟用户, 在同一个场景中, 可以用多个用户组使用同一个脚本.
4 集合点(同步点): 如果当前场景中的脚本中包含集合点(rendezvous), 那么可以通过Scenario/Rendezvous打开集合点信息面板来设置集合点信息
4.1 点击Policy按钮: 这里设置集合点的策略. 三个Release选项用来设置释放集合点的策略, timeout表明第一个vuser等待一定时间后就不再等待, 释放等待用户, 继续执行场景.
5 负载生成器: 网内安装了负载生成器的机器都可以被同一个Controller控制用来生成负载.
6 在Controller中可以对vuser组进行运行时设置, 这里可以设置网络带宽来模拟真实的情况.
7 在schedule(调度栏)内可以设置vuser加载及卸载的方式等调度策略.
8 Scenario/Convert scenario to the
percentage mode可以将场景转换为百分比模式. 百分比模式的场景只是对场景内的vuser
group中的vuser数量进行了百分比分配
9 面向场景的目标类型: 一次只能设置一个目标.
9.1 virtual users: 虚拟用户数量, 如果测试服务器的并发处理能力, 使用这个目标.
9.2 hits per second: 每秒点击数, 测试web的真正响应处理能力.
9.3 transaction per second: 每秒事务数, 这种目标需要选择事务名.transaction response time: 事务响应时间, 需要选择事务名, 测试web的真正响应处理能力.
9.4 pages per minute: 每分钟页面响应数
10 Controller的加载策略: 
10.1 在使用pages per minute, hits/transaction per second这几种目标时, 加载时首先用最小用户数除以定义的目标, 得到一个值, 然后确定每个用户应该达到的数据, 然后Controller开始按照以下策略加载用户:
10.1.1 如果选择的是自动加载vuser, controller会首先记载50个vuser, 如果定义的最大用户数小于50, 会一次加载所有的vuser.
10.1.2 如果选择的是在场景运行一段时间后达到目标, LoadRunner会尝试在定义的这段时间内达到目标, 根据时间限制和计算出的单用户数据确定第一批加载多少vuser.
10.1.3 如果选择的是按照一定的阶段达到目标(也就是x长时间内达到y数据, 然后达到下一目标),
LoadRunner计算每个用户应该达到的数字后, 再确定第一批加载多少用户.
10.2 每加载一批用户, LoadRunner会判断是否达到这批用户的目标, 如果这批用户目标没有达到,
LoadRunner重新计算每一个用户应该达到的目标数字后, 重新调整下一批加载用户数量.
10.3 如果Controller加载了最多数量的用户还没有达到预订目标, 会重新计算每个用户的目标,然后同时运行最大数量的用户, 尝试达到预订目标
10.4 如果出现以下情况, pages per minute, hits/transaction per second三种类型的面向目标场景会置于”Failed”状态:
10.4.1 Controller使用了指定的最大数量用户, 并且两次都没有达到目标
10.4.2 所有的用户运行都失败
10.4.3 没有足够的LoadGenerator机器
10.4.4 Controller增加了几批用户后, pages per minute, hits/transaction per second数据没有增加.
11 IP欺骗设置: 应对某些服务器要求不允许单IP多登的测试.
11.1 在负载生成器机器上(必须使用固定IP), “Windows开始”/LoadRunner/Tools/Ip wizard打开IP向导, 根据向导配置IP列表.
11.2 在Controller中, Scenario/Enable IP spoofer打开IP欺骗
12 场景的运行时控制
12.1 场景开始运行后, 可以通过stop按钮停止, 但是停止的方式需要在运行之前通过Tools/Options/Run-time settings中设置好
12.2 场景开始运行后的reset按钮用来将方案中的所有vuser组重置为其方案前的关闭状态
12.3 Vusers用来查看vuser组内每个vuser的详细状态
12.4 Run/Stop Vusers打开”运行/停止vuser”对话框, 在场景运行时决定是继续执行还是停止某个用户组.
12.5 运行时释放集合点用户: Scenario/Rendezvous然后选定用户disable vuser
13 如果系统提供的数据采集点不能满足需求, 可以在脚本中用lr_user_data_point自定义数据采集点.
14 判断磁盘瓶颈的方法: 每磁盘I/O数 = [读次数+(4*写次数)]/磁盘个数, 如果每磁盘的I/O数大于磁盘的处理能力, 那么磁盘存在瓶颈.
#寻找系统瓶颈的得力助手—Analysis
1 Analysis功能:
1.1 Analysis图有助于确定系统性能瓶颈.
1.2 “图数据”视图和”原始数据”视图以电子表格格式显示用于生成图的实际数据.
1.3 “报告”功能可以使用户查看每个图的摘要, HTML报告或各种性能和活动报告.
2 摘要报告(summary): 
2.1 Analysis summary(统计摘要):
2.1.1 Maximum Running vusers: 最大同时运行用户数
2.1.2 Total Throughput(bytes): 吞吐量
2.1.3 Average Thoughput(bytes/second): 吞吐率
2.1.4 Total Hits: 总点击数
2.1.5 Average Hits per Second: 每秒点击数
2.1.6 View HTTP Responses Summary: 查看HTTP响应的摘要
3 Trasaction summary(事务摘要):
3.1 Minimum: 事务最小时间
3.2 Average: 平均事务时间
3.3 Maximum: 事务最大时间
3.4 Std.Deviation: 标准方差. 值越大数据越离散也就说明不稳定.
3.5 90 Percent: 90%的事务消耗的时间, 通常这个值比总平均时间个更可靠.
3.6 Pass/Fail/Stop: 通过/失败/中途停止的事务数
4 在Average Transaction Response Time图中, 可以选择某个事务曲线, 右键”Web Page Breakdown for login”将事务进行分解, 查看事务过程中每个请求的每一步是怎么样完成的.
5 Time to first buffer breakdown(Over
Time)图中可以对比页面响应时间中的服务器时间和网络时间, 从而分析是网络还是服务器造成的耗时.
6 Page Download Time Breakdown(Over
Time)图中可以看出每次请求详细分解的请求时间(包括客户端时间, 连接时间, DNS解析时间, 错误时间, 首次缓存时间, FTP鉴权时间, 接收时间, SSL处理时间等等).
7 图的合并: 
7.1 叠加: 重叠共用一个x轴的两个图的内容, 合并图使用左右两个不同的y轴
7.2 平铺: 共用同一个x轴的数据, 但显示上上下分离, 合并图仍然是左右两个不同的y轴
7.3 关联: 当前图的y轴成为合并图的x轴, 被合并图的y轴是合并图的y轴
8 可以使用Reports生成报告.
 
