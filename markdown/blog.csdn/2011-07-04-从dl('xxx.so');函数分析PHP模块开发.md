#从dl('xxx.so');函数分析PHP模块开发
author: selfimpr
blog: http://blog.csdn.net/lgg201
mail: lgg860911@yahoo.com.cn
转载请声明出处.
最近在学习PHP模块开发相关的知识, 再看了dl()函数的流程之后, 对模块加载的处理流程做一个总结, 希望可以在PHP模块开发上帮助到大家.
进入正题.##PHP的代码架构
![](http://hi.csdn.net/attachment/201107/4/0_1309773216dp36.gif)
上图摘自Extending and Embedding PHP(Sams).
从图中可以看出, PHP所有的部分都处在一个被称为TSRM的层中, TSRM层是负责线程安全管理的. 最底下的SAPI是对外提供服务的接口, 比如命令行的sapi为cli, php-fpm则是fastcgi的sapi, apache的模块方式也是一种sapi.
中间是PHP内核和Zend 引擎. 从图中的文字可以看出, PHP内核负责请求管理/网络和文件操作, Zend内核则负责编译和执行/内存和资源的分配.
在所有这些之上, 是扩展层, PHP中多数对外接口都是通过扩展层来提供的, 比如, standard, string等语言基础也被以扩展形式提供.
扩展(以后称为模块)加载到PHP中的方式有两种: 静态编译, 动态链接.
静态编译需要重新生成php的configure脚本, 这里不再赘述. 动态链接方式是将模块编译为一个.so文件, 然后动态的加载到php中.
加载.so文件的方式有两种, 一种是将其写到php.ini文件中, 比如: extension=apc.so, 另外一种就是在代码中使用dl(‘xxx.so’).
##dl($library)
函数的作用就是把一个模块加载进来, 使其内部提供的能力可用.
dl()函数的源代码在PHP源代码根目录(简写为PHP_SRC_HOME)下, PHP_SRC_HOME/ext/standard/dl.c, 处理关键流程如下:

###PHP_FUNCTION(dl)

```php
PHPAPI PHP_FUNCTION(dl)
{
	//...
    php_dl(filename, MODULE_TEMPORARY, return_value, 0 TSRMLS_CC);
	//... 
}
```
###php_dl

```php
PHPAPI void php_dl(char *file, int type, zval *return_value, int start_now TSRMLS_DC)
{
    if (php_load_extension(file, type, start_now TSRMLS_CC) == FAILURE) {
       //...
}
```
###php_load_extension

```php
PHPAPI int php_load_extension(char *filename, int type, int start_now TSRMLS_DC) {
	//文件名解析相关

	//加载动态链接库
	handle = DL_LOAD(libpath);

	//加载错误处理

	//获取模块的get_module函数(重点, 模块初始入口)
	get_module = (zend_module_entry *(*)(void)) DL_FETCH_SYMBOL(handle, "get_module");

	//get_module函数获取错误处理

	//那个get_module()得到struct zend_module_entry
	module_entry = get_module();
	//...

	//注册模块(重点, 函数在这里被注册)
	if ((module_entry = zend_register_module_ex(module_entry TSRMLS_CC)) == NULL) {
		//错误处理
	}

	//模块启动(重点, PHP_MINIT_FUNCTION)
	if ((type == MODULE_TEMPORARY || start_now) && zend_startup_module_ex(module_entry TSRMLS_CC) == FAILURE) {
		//错误处理
	}

	//模块请求启动(重点, PHP_RINIT_FUNCTION)
	if ((type == MODULE_TEMPORARY || start_now) && module_entry->request_startup_func) {
		//错误处理
	}
	return SUCCESS;
}
```
##流程中的重点问题
###get_module函数

```php
get_module = (zend_module_entry *(*)(void)) DL_FETCH_SYMBOL(handle, "get_module");
```
这一句代码经过宏扩展之后如下:

```php
get_module = (zend_module_entry *(*)(void)) dlsym(handle, "_get_module");
```
google一下dlsym()函数是干什么的, 我们很容易理解这一句代码, 这是从刚才加载的动态链接库中获取了一个函数指针, 也就是我们在开发模块的时候定义的get_module函数.
大家可以去看看PHP_SRC_HOME/ext/下的扩展主文件中, 都会有类似你的代码:

```php
#ifdef COMPILE_DL_SAMPLE
ZEND_GET_MODULE(sample)
#endif
```
经过宏展开为(暂不考虑针对GNU的__attribute__和针对C++的extern “C”):

```php
zend_module_entry *get_module(void) { return &sample_module_entry; }
```
通过把dl()函数的加载过程和模块开发时的定义联系起来, 我们可以看到, 模块被加载的时候, 我们自定义的zend_module_entry从这里被传递出去.
###模块的注册

```php
module_entry = zend_register_module_ex(module_entry TSRMLS_CC)
```
上面的代码是从函数php_load_extension中摘出的, 我们继续深入zend_register_module_ex()找到我们关注的函数注册:

```php
if (module->functions && zend_register_functions(NULL, module->functions, NULL, module->type TSRMLS_CC)==FAILURE) {
```
继续深入到zend_register_functions函数中:

```php
ZEND_API int zend_register_functions(zend_class_entry *scope, const zend_function_entry *functions, HashTable *function_table, int type TSRMLS_DC) /* {{{ */ {
	//...

	//重点 如果没有函数符号表, 取全局函数符号表
	if (!target_function_table) {
		target_function_table = CG(function_table);
	}

	//...

	//重点 循环zend_function_entry[]
	while (ptr->fname) {
		//向函数符号表增加函数
		if (zend_hash_add(target_function_table, lowercase_name, fname_len+1, &function, sizeof(zend_function), (void**)®_function) == FAILURE) {
			//错误处理
		}

		//...

		//准备遍历zend_function_entry[]下一个元素
		ptr++;

		//...
	}
	//...

	return SUCCESS;
}
```
在获取函数符号表的时候, 使用了CG宏:

```php
target_function_table = CG(function_table);
```
我们分两种情况解开这个宏:

```php
//非线程安全
compiler_globals.function_table

//线程安全
(((zend_compiler_globals *) (*((void ***) tsrm_ls))[ compiler_globals_id - 1])-> function_table)
```
最终, 它们获取的都是一个全局结构struct zend_compiler_globals中的function_table元素, 该元素是一个HashTable.
下面的循环就很好理解了, 把模块开发时zend_function_entry中的函数遍历增加到HashTable中就OK了.
###模块启动/模块请求启动
这两个部分是很容易理解的, 分别对应的是模块开发中的PHP_MINIT_FUNCTION()和PHP_RINIT_FUNCTION()
##一个最简单的模块
在介绍了上面的内容后, 开发一个PHP模块的思路应该会清晰很多.
我们假设模块的名称为”sample”, 有一个头文件和一个源文件, 首先是头文件:

```cpp
#ifndef PHP_SAMPLE_H
/* 预防多次包含 */
#define PHP_SAMPLE_H

/* 定义扩展属性 */
#define PHP_SAMPLE_EXTNAME  "sample"
#define PHP_SAMPLE_EXTVER   "1.0"

/* 引入源文件外部的配置选项 */
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

/* 包含PHP标准头文件 */
#include "php.h"

/* 定义入口指针符号, Zend在加载的时候使用它 */
extern zend_module_entry sample_module_entry;
extern zend_function_entry sample_functions[];
#define phpext_sample_ptr &sample_module_entry

/* 定义函数 */
PHP_FUNCTION(sample_hello_world);

#endif /* PHP_SAMPLE_H */
```
接下来是源文件:

```cpp
#include "php_sample.h"

zend_module_entry sample_module_entry = {
#if ZEND_MODULE_API_NO >= 20010901
    STANDARD_MODULE_HEADER,
#endif
    PHP_SAMPLE_EXTNAME,
    sample_functions, /* Functions */
/* 本例没有实现这些方法,不过实现和普通方法基本一致 */
    NULL, /* MINIT */
    NULL, /* MSHUTDOWN */
    NULL, /* RINIT */
    NULL, /* RSHUTDOWN */
    NULL, /* MINFO */
#if ZEND_MODULE_API_NO >= 20010901
    PHP_SAMPLE_EXTVER,
#endif
    STANDARD_MODULE_PROPERTIES
};

#ifdef COMPILE_DL_SAMPLE
ZEND_GET_MODULE(sample)
#endif

/* 函数入口 */
zend_function_entry sample_functions[] = {
    PHP_FE(sample_hello_world,              NULL)
    {NULL, NULL, NULL}
};

/* ------------------- 函数定义 -----------------------*/

PHP_FUNCTION(sample_hello_world)
{
    php_printf("Hello world!\n");
}
```
##完
Over了, 给大家推荐一本书<Sams Extending and Embedding PHP>.

