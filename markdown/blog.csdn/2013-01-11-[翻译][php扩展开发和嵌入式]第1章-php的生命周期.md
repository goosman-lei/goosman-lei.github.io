
**全部翻译内容pdf文档下载地址: [http://download.csdn.net/detail/lgg201/5107012](http://download.csdn.net/detail/lgg201/5107012)**
本书目前在github上由laruence(http://www.laruence.com)和walu(http://www.walu.cc)两位大牛组织翻译. 该翻译项目地址为: https://github.com/walu/phpbook
原书名: <Extending and Embedding PHP>
原作者: Sara Golemon
译者: goosman.lei(雷果国)
译者Email: lgg860911@yahoo.com.cn
译者Blog: http://blog.csdn.net/lgg201


**php的生命周期**
在常见的webserver环境中, 你不能直接启动php解释器; 一般是启动apache或其他webserver, 由它们加载php处理需要处理的脚本(请求的.php文档).
**一切都从sapi开始**
尽管看起来有所不同, 但实际上CLI的行为和web方式一致. 在命令行中键入php命令将启动"命令行sapi", 它实际上就像一个设计用于服务单请求的迷你版webserver. 当脚本运行完成后, 这个迷你的php-webserver终止并返回控制给shell.
**启动和终止**
这里的启动和终止过程分为两个独立的启动阶段和两个独立的终止阶段. 一个周期用于php解释器整体执行所需结构和值的初始化设置, 它们在sapi生命周期中持久存在. 另一个则仅服务于单页面请求, 生命周期短暂一些.
初始化启动在所有的请求发生之前, php调用每个扩展的MINIT(模块初始化)方法. 这里, 扩展可能会定义常量, 定义类, 注册资源, 流, 过滤处理器等所有将要被请求脚本所使用的资源. 所有这些都有一个特性, 就是它们被设计跨所有请求存在, 也可以称为"持久".
常见的MINIT方法如下:

```cpp
/* 初始化myextension模块
 * 这在sapi启动后将立即发生
 */
PHP_MINIT_FUNCTION(myextension)
{
    /* 全局: 第12章 */

#ifdef ZTS
    ts_allocate_id(&myextension_globals_id,
        sizeof(php_myextension_globals),
        (ts_allocate_ctor) myextension_globals_ctor,
        (ts_allocate_dtor) myextension_globals_dtor);
#else
    myextension_globals_ctor(&myextension_globals TSRMLS_CC);
#endif


    /* REGISTER_INI_ENTRIES() 指向一个全局的结构, 我们将在第13章"INI设置"中学习 */
    REGISTER_INI_ENTRIES();


    /* 等价于define('MYEXT_MEANING', 42); */
    REGISTER_LONG_CONSTANT("MYEXT_MEANING", 42, CONST_CS | CONST_PERSISTENT);
    /* 等价于define('MYEXT_FOO', 'bar'); */
    REGISTER_STRING_CONSTANT("MYEXT_FOO", "bar", CONST_CS | CONST_PERSISTENT);


    /* 资源: 第9章 */
    le_myresource = zend_register_list_destructors_ex(
                    php_myext_myresource_dtor, NULL,
                    "My Resource Type", module_number);
    le_myresource_persist = zend_register_list_destructors_ex(
                    NULL, php_myext_myresource_dtor,
                    "My Resource Type", module_number);


    /* 流过滤器: 第16章 */
    if (FAILURE == php_stream_filter_register_factory("myfilter",
                   &php_myextension_filter_factory TSRMLS_CC)) {
        return FAILURE;
    }


    /* 流包装器: 第15章 */
    if (FAILURE == php_register_url_stream_wrapper ("myproto",
                   &php_myextension_stream_wrapper TSRMLS_CC)) {
        return FAILURE;
    }


    /* 自动全局变量: 第12章 */
#ifdef ZEND_ENGINE_2
    if (zend_register_auto_global("_MYEXTENSION", sizeof("_MYEXTENSION") - 1,
                                                NULL TSRMLS_CC) == FAILURE) {
        return FAILURE;
    }
    zend_auto_global_disable_jit ("_MYEXTENSION", sizeof("_MYEXTENSION") - 1
                                                     TSRMLS_CC);
#else
    if (zend_register_auto_global("_MYEXTENSION", sizeof("_MYEXTENSION") - 1
                                                     TSRMLS_CC) == FAILURE) {
        return FAILURE;
    }
#endif
    return SUCCESS;
}
```
在一个请求到达时, php会安装一个操作环境, 该环境包含符号表(变量存储), 并且会同步每个目录的配置值. php接着遍历所有的扩展, 这一次调用每个扩展的RINIT(请求初始化)方法. 这里, 扩展可能充值全局变量到默认值, 预置变量到脚本的符号表, 或执行其他的任务比如记录页面请求日志到文件. RINIT之于所有脚本请求就像auto_prepend_file指令一样.
RINIT方法的写法如下:

```cpp
/* 每个页面请求开始之前执行
 */
PHP_RINIT_FUNCTION(myextension)
{
    zval *myext_autoglobal;


    /* 初始化MINIT函数中定义的自动全局变量为空数组. 这等价于$_MYEXTENSION = array(); */
    ALLOC_INIT_ZVAL(myext_autoglobal);
    array_init(myext_autoglobal);
    zend_hash_add(&EG(symbol_table), "_MYEXTENSION", sizeof("_MYEXTENSION") - 1,
                                (void**)&myext_autoglobal, sizeof(zval*), NULL);


    return SUCCESS;
}
```
在一个请求完成处理后(到达脚本文件末尾或调用了die()/exit()语句), php通过调用每个扩展的RSHUTDOWN(请求终止)开始清理过程. 就像RINIT对应于auto_prepend_file, RSHUTDOWN可以类比auto_append_file指令. 在RSHUTDOWN和auto_append_file之间, 最重要的不同是: 无论如何, RSHUTDOWN总会被执行, 而用户空间脚本的die()/exit()调用会跳过所有的auto_append_file.
在符号表和其他资源释放之前所需要做的最后一件事旧是RSHUTDOWN. 在所有的RSHUTDOWN方法完成后, 符号表中的所有变量都会被立即unset(), 
在此期间, 所有非持久化资源和对象的析构器都将被调用去优雅的释放资源.

```cpp
/* 每个页面请求结束后调用 */
PHP_RSHUTDOWN_FUNCTION(myextension)
{
    zval **myext_autoglobal;


    if (zend_hash_find(&EG(symbol_table), "_MYEXTENSION", sizeof("_MYEXTENSION"),
                                         (void**)&myext_autoglobal) == SUCCESS) {
        /* 做一些对$_MYEXTENSION数组的值有意义的处理 */
        php_myextension_handle_values(myext_autoglobal TSRMLS_CC);
    }
    return SUCCESS;
}
```
最后, 当所有的请求都被满足(完成处理)后, webserver或其他sapi就开始准备终止, php循环执行每个扩展的MSHUTDOWN(模块终止)方法. 这是MINIT周期内, 扩展最后一次卸载处理器和释放持久化分配的内存的机会.

```cpp
/* 这个模块正在被卸载, 常量和函数将被自动的卸载, 持久化资源, 类, 流处理器必须手动的卸载. */
PHP_MSHUTDOWN_FUNCTION(myextension)
{
    UNREGISTER_INI_ENTRIES();
    php_unregister_url_stream_wrapper ("myproto" TSRMLS_CC);
    php_stream_filter_unregister_factory ("myfilter" TSRMLS_CC);
    return SUCCESS;
}
```
**生命周期**
每个php实例, 无论从init脚本启动还是从命令行启动, 接下来都是上一节讲到的一系列请求/模块的初始化/终止事件, 以及脚本自身的执行. 每个启动和终止阶段会被执行多少次? 以什么频率执行? 都依赖于所使用的sapi. 下面讨论4种最常见的sapi: cli/cgi, 多进程模块, 多线程模块, 嵌入式.
**cli生命周期**
cli(和cgi)sapi在它的单请求生命周期中相当特殊, 因为此时整个php的生命周期只有一个请求. 不过, 麻雀虽小五脏俱全, 前面讲的各个阶段仍然会全部执行. 下图是从命令行调用php解释器处理test.php脚本的处理过程:
![](http://img.my.csdn.net/uploads/201301/11/1357887844_7952.png)
**多进程生命周期**
php最常见的用法是将php构建为apache 1或使用pre-fork MPM的apache 2的apxs模块, 将php嵌入到webserver中. 还有一些其他webserver也是属于这一类的, 本书后面将它们统称为"多进程模块".
将它们称为多进程模块是因为当apache启动时, 它会立即fork出一些子进程, 每个都有自己的独立的进程空间, 互相之间独立. 在一个子进程中, php实例的生命周期就像下图所示一样. 这里唯一的变化是多个请求被夹在在单个的MINIT/MSHUTDOWN对中:
![](http://img.my.csdn.net/uploads/201301/11/1357887886_6678.png)
这种模式不允许任意子进程知道其他子进程拥有的数据, 不过它允许子进程死亡并被替换, 而不影响其他子进程的稳定性. 下图战士了一个apache实例中的多个进程以及它们对MINIT, RINIT, RSHUTDOWN, MSHUTDOWN方法的调用.
![](http://img.my.csdn.net/uploads/201301/11/1357887941_1136.png)
**多线程生命周期**
随着发展, php逐渐的被一些webserver以多线程方式使用, 比如IIS的isapi接口, apapche 2的worker mpm. 在多线程webserver中永远都只有一个进程在运行, 但是在进程空间中有多个线程同时执行. 这样做能降低一些负载, 包括避免了MINIT/MSHUTDOWN的重复调用, 真正的全局数据只被分配和初始化一次, 潜在的打开了多个请求的信息共享之门. 下图展示了apache 2这样的多线程webserver上运行php时的进程状态:
![](http://img.my.csdn.net/uploads/201301/11/1357887975_4224.png)

**嵌入式生命周期**
回顾前面, 嵌入式sapi只是sapi的另外一种实现, 它还是遵循和cli, apxs, isapi接口一致的规则, 因此很容易猜到请求的生命周期遵循相同的基本路径: 模块初始化 => 请求初始化 => 请求 => 请求终止 => 模块终止. 实际上, 嵌入式sapi和它的同族一样遵循着这些步骤.
让嵌入式sapi变得特殊的是它可能被当做一个整个请求的一部分被潜入到多个脚本片段中. 多数情况下控制会在php和调用应用之间多次来回的传递.
虽然一个嵌入请求可能由一个或多个代码元素组成, 但嵌入式应用还是受和webserver一样的请求隔离影响. 为了处理两个或多个并行的嵌入环境, 你的应用要么像apache 1去fork, 要么旧像apache 2线程化. 尝试在单个非线程进程空间中处理两个独立的请求环境将产生不可预料的结果, 这肯定是你不期望的.
**Zend线程安全**
当php还在幼儿期的时候, 它作为一个单进程cgi运行, 并没有线程安全的概念, 因为没有比单个请求存活更久的进程空间. 内部变量可以在全局作用域中定义, 访问, 修改, 只要初始化没有问题就不会产生严重后果. 任何没有被正确清理的资源都会在cgi进程终止时被释放.
后来, php嵌入了多进程webserver, 比如apache. 给定的内部变量仍然可以定义在全局并且可以通过在每个请求启动时正确的初始化, 终止时去做适当的清理工作来做到安全访问, 因为在一个进程空间中同时只会有一个请求. 这个时候, 增加了每个请求的内存管理, 以放置资源泄露的增长失去控制.
单进程多线程webserver出现后, 就需要一种对全局数据处理的新的方法. 最后这作为新的一层TSRM(线程安全资源管理)
**线程安全Vs.废线程安全定义**
在一个简单的非线程应用中, 你可能很喜欢定义全局变量, 将它们放在你的源代码的顶部. 编译器会在你的程序的数据段分配内存块保存信息.
在多线程应用中, 每个线程需要它自己的数据元素, 需要为每个线程分配独立的内存块. 一个给定线程在它需要访问自己的数据时需要能够正确的访问到自己的这个内存块.
**线程安全数据池**
在一个扩展的MINIT阶段, 扩展可以调用ts_allocate_id()一次或多次告诉TSRM层它需要多少数据空间, TSRM接收到通知后, 将总的运行数据空间增大请求的字节数, 并返回一个新的唯一的标识, 标记线程数据池的数据段部分.

```cpp
typedef struct {
    int sampleint;
    char *samplestring;
} php_sample_globals;
int sample_globals_id;
PHP_MINIT_FUNCTION(sample)
{
    ts_allocate_id(&sample_globals_id,
        sizeof(php_sample_globals),
        (ts_allocate_ctor) php_sample_globals_ctor,
        (ts_allocate_dtor) php_sample_globals_dtor);
    return SUCCESS;
}
```
当一个请求需要访问数据段的时候，扩展从TSRM层请求当前线程的资源池，以ts_allocate_id()返回的资源ID来获取偏移量。
换句话说，在代码流中，你可能会在前面所说的MINIT语句中碰到SAMPLE_G(sampleint) = 5;这样的语句。在线程安全的构建下，这个语句通过一些宏扩展如下：

```cpp
(((php_sample_globals*)(*((void ***)tsrm_ls))[sample_globals_id-1])->sampleint = 5;
```
如果你看不懂上面的转换也不用沮丧，它已经很好的封装在PHPAPI中了，以至于许多开发者都不需要知道它怎样工作的。
**当不在线程环境时**
因为在PHP的线程安全构建中访问全局资源涉及到在线程数据池查找对应的偏移量，这是一些额外的负载，结果就是它比对应的非线程方式（直接从编译期已经计算好的真实的全局变量地址中取出数据）慢一些。
考虑上面的例子，这一次在非线程构建下：

```cpp
typedef struct {
    int sampleint;
    char *samplestring;
} php_sample_globals;
php_sample_globals sample_globals;
PHP_MINIT_FUNCTION(sample)
{
    php_sample_globals_ctor(&sample_globals TSRMLS_CC);
    return SUCCESS;
}
```
首先注意到的是这里并没有定义一个int型的标识去引用全局的结构定义，只是简单的在进程的全局空间定义了一个结构体。也就是说SAMPLE_G(sampleint) = 5;展开后就是sample_globals.sampleint = 5; 简单，快速，高效。
非线程构建还有进程隔离的优势，这样给定的请求碰到完全出乎意料的情况时，它也不会影响其他进程，即便是产生段错误也不会导致整个webserver瘫痪。实际上，Apache的MaxRequestsPerChild指令就是设计用来提升这个特性的，它经常性的有目的性的kill掉子进程并产生新的子进程，来避免某些可能由于进程长时间运行“累积”而来的问题（比如内存泄露）。
**访问全局变量**
在创建一个扩展时，你并不知道它最终的运行环境是否是线程安全的。幸运的是，你要使用的标准包含文件集合中已经包含了条件定义的ZTS预处理标记。当PHP因为SAPI需要或通过enable-maintainer-zts选项安装等原因以线程安全方式构建时，这个值会被自动的定义，并可以用一组#ifdef ZTS这样的指令集去测试它的值。
就像你前面看到的，只有在PHP以线程安全方式编译时，才会存在线程安全池，只有线程安全池存在时，才会真的在线程安全池中分配空间。这就是为什么前面的例子包裹在ZTS检查中的原因，非线程方式供非线程构建使用。
在本章前面PHP_MINIT_FUNCTION(myextension)的例子中，你可以看到#ifdef ZTS被用作条件调用正确的全局初始代码。对于ZTS模式它使用ts_allocate_id()弹出myextension_globals_id变量，而非ZTS模式只是直接调用myextension_globals的初始化方法。这两个变量已经在你的扩展源文件中使用Zend宏：DECLARE_MODULE_GLOBALS(myextension)声明，它将自动的处理对ZTS的测试并依赖构建的ZTS模式选择正确的方式声明。
在访问这些全局变量的时候，你需要使用前面给出的自定义宏SAMPLE_G()。在第12章，你将学习到怎样设计这个宏以使它可以依赖ZTS模式自动展开。
**即便你不需要线程也要考虑线程**
正常的PHP构建默认是关闭线程安全的，只有在被构建的sapi明确需要线程安全或线程安全在./configure阶段显式的打开时，才会以线程安全方式构建。
给出了全局查找的速度问题和进程隔离的缺点后，你可能会疑惑为什么明明不需要还有人故意打开它呢？这是因为，多数情况下，扩展和SAPI的开发者认为你是线程安全开关的操作者，这样做可以很大程度上确保新代码可以在所有环境中正常运行。
当线程安全启用时，一个名为tsrm_ls的特殊指针被增加到了很多的内部函数原型中。这个指针允许PHP区分不同线程的数据。回想一下本章前面ZTS模式下的SAMPLE_G()宏函数中就使用了它。没有它，正在执行的函数就不知道查找和设置哪个线程的符号表；不知道应该执行哪个脚本，引擎也完全无法跟踪它的内部寄存器。这个指针保留了线程处理的所有页面请求。
这个可选的指针参数通过下面一组定义包含到原型中。当ZTS禁用时，这些定义都被展开为空；当ZTS开启时，它们展开如下：

```cpp
#define TSRMLS_D     void ***tsrm_ls
#define TSRMLS_DC     , void ***tsrm_ls
#define TSRMLS_C     tsrm_ls
#define TSRMLS_CC     , tsrm_ls
```
非ZTS构建对下面的代码看到的是两个参数：int, char *。在ZTS构建下，原型则包含三个参数：int, char *, void ***。当你的程序调用这个函数时，只有在ZTS启用时才需要传递第三个参数。下面代码的第二行展示了宏的展开：

```cpp
int php_myext_action(int action_id, char *message TSRMLS_DC);
php_myext_action(42, "The meaning of life" TSRMLS_CC);
```
通过在函数调用中包含这个特殊的变量，php_myext_action就可以使用tsrm_ls的值和MYEXT_G()宏函数一起访问它的线程特有全局数据。在非ZTS构建上，tsrm_ls将不可用，但是这是ok的，因为此时MYEXT_G()宏函数以及其他类似的宏都不会使用它。
现在考虑，你在一个新的扩展上工作，并且有下面的函数，它可以在你本地使用CLI SAPI的构建上正常工作，并且即便使用apache 1的apxs SAPI编译也可以正常工作：

```cpp
static int php_myext_isset(char *varname, int varname_len)
{
    zval **dummy;


    if (zend_hash_find(EG(active_symbol_table),
        varname, varname_len + 1,
        (void**)&dummy) == SUCCESS) {
        /* Variable exists */
        return 1;
    } else {
        /* Undefined variable */
        return 0;
    }
}
```
所有的一切看起来都工作正常，你打包这个扩展发送给他人构建并运行在生产服务器上。让你气馁的是，对方报告扩展编译失败。
事实上它们使用了Apache 2.0的线程模式，因此它们的php构建启用了ZTS。当编译期碰到你使用的EG()宏函数时，它尝试在本地空间查找tsrm_ls没有找到，因为你并没有定义它并且没有在你的函数中传递。
修复这个问题非常简单；只需要在php_myext_isset()的定义上增加TSRMLS_DC，并在每行调用它的地方增加TSRMLS_CC。不幸的是，现在对方已经有点不信任你的扩展质量了，这样就会推迟你的演示周期。这种问题越早解决越好。
现在有了enable-maintainer-zts指令。通过在./configure时增加该指令来构建php，你的构建将自动的包含ZTS，哪怕你当前的SAPI（比如CLI）不需要它。打开这个开关，你可以避免这些常见的不应该出现的错误。
注意：在PHP4中，enable-maintainer-zts标记等价的名字是enable-experimental-zts；请确认使用你的php版本对应的正确标记。
**寻回丢失的tsrm_ls**
有时，我们需要在一个函数中使用tsrm_ls指针，但却不能传递它。通常这是因为你的扩展作为某个使用回调的库的接口，它并没有提供返回抽象指针的地方。考虑下面的代码片段：

```cpp
void php_myext_event_callback(int eventtype, char *message)
{
    zval *event;


    /* $event = array('event'=>$eventtype,
                    'message'=>$message) */
    MAKE_STD_ZVAL(event);
    array_init(event);
    add_assoc_long(event, "type", eventtype);
    add_assoc_string(event, "message", message, 1);


    /* $eventlog[] = $event; */
    add_next_index_zval(EXT_G(eventlog), event);
}
PHP_FUNCTION(myext_startloop)
{
    /* The eventlib_loopme() function,
     * exported by an external library,
     * waits for an event to happen,
     * then dispatches it to the
     * callback handler specified.
     */
    eventlib_loopme(php_myext_event_callback);
}
```
虽然你可能不完全理解这段代码，但你应该注意到了回调函数中使用了EXT_G()宏函数，我们知道在线程安全构建下它需要tsrm_ls指针。修改函数原型并不好也不应该这样做，因为外部的库并不知道php的线程安全模型。那这种情况下怎样让tsrm_ls可用呢？
解决方案是前面提到的名为TSRMLS_FETCH()的Zend宏函数。将它放到代码片段的顶部，这个宏将执行给予当前线程上下文的查找，并定义本地的tsrm_ls指针拷贝。
这个宏可以在任何地方使用并且不用通过函数调用传递tsrm_ls，尽管这看起来很诱人，但是，要注意到这一点：TSRMLS_FETCH调用需要一定的处理时间。这在单次迭代中并不明显，但是随着你的线程数增多，随着你调用TSRMLS_FETCH()的点的增多，你的扩展就会显现出这个瓶颈。因此，请谨慎的使用它。
注意：为了和c++编译器兼容，请确保将TSRMLS_FETCH()和所有变量定义放在给定块作用域的顶部（任何其他语句之前）。因为TSRMLS_FETCH()宏自身有多种不同的解析方式，因此最好将它作为变量定义的最后一行。
**小结**
本章中主要是对后续章节将要解释的各种概念的一个概览. 你还应该对整件事建立了基础的认识, 它不只是要构建扩展, 还有幕后的Zend引擎和TSRM层, 它们将使你在将php嵌入到你的应用时获利.

[目录](http://blog.csdn.net/lgg201/article/details/8493725#toc)
[下一章: 变量的里里外外](http://blog.csdn.net/lgg201/article/details/8516213)
