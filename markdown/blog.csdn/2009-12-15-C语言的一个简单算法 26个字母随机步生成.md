一个简单的小程序, 原题目见<C语言程序设计-现代方法>第八章练习13.
由于自己只看到第八章, 所以, 不敢贸然使用函数等其他内容, 高手请放声大笑.
 

```cpp
#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
#include &lt;stdlib.h&gt;

#define ROWS 10
#define COLS 10

/**
 * @author: selfimpr
 * @blog: http://blog.csdn.net/lgg201
 * @email: goosman.lei@gmail.com
 * 功能:
 *    ROWS * COLS的方格中实现随机步. 即将26个大写字母按顺序以随机的方向排列.
 *    这里实现的是八个方向(汗, 不知道有没有八个方向一说.)
 * 缺陷:
 *    有较大几率被困死, 没有做优化处理.
 * 数据结构设计:
 *    1. ROWS, COLS宏定义了棋盘的大小
 *    2. board二维数组定义了棋盘, 没有字母的以.号补空
 *    3. i, j为循环因子, 在方向控制时, 充当了移动的方向控制.
 *    4. direction为方向控制变量.
 *    5. ch是顺序获取字母的循环因子.
 *    6. row, col存储临时的移动坐标, 存储该坐标为了保证获取的方向不可用时, 不影响原数据.
 * 流程:
 *    1. 初始化棋盘, 以.号初始化所有元素, 打印一次空棋盘后, 将棋盘[0, 0]坐标元素设置为'A'.
 *    2. 设置随机数生成种子为当前时间, 以保证每次生成的随机数不同.
 *    2. 循环处理字母
 *    3. 获取随机方向, 并根据方向取得移动后的坐标, 保存到临时变量row和col中.
 *    4. 判断新的坐标是否有效
 *    5. 如果新坐标不可用, 到第3步重新获取方向.
 *    6. 如果新坐标有效:
 *	 6.1. 设置棋盘对应位置的字母
 *	 6.2. 将临时坐标信息转存到真正的当前坐标i, j中.
 *	 6.3. 获取下一个字母
 *	 6.4. 到第2步重新开始处理下一个字母.
 *    7. 打印最后生成的棋盘.
 *
 */
int main() {
   char board[ROWS][COLS];
   int i, j, direction;
   srand( (unsigned) time(NULL));

   for(i = 0; i &lt; ROWS; i ++) {
      for(j = 0; j &lt; COLS; j ++) {
	 board[i][j] = '.';
      }
   }
   for(i = 0; i &lt; ROWS; i ++) {
      for(j = 0; j &lt; COLS; j ++) {
	 printf("%c ", board[i][j]);
      }
      printf("/n");
   }
   board[0][0] = 'A';
   printf("/n");

   char ch;
   i = 0; j = 0;
   int row = 0, col = 0;
   for(ch = 'B'; ch &lt;= 'Z';) {
      direction = rand() % 8;
      switch(direction) {
	 case 0: /* top */
	    row = i - 1;
	    col = j;
	    break;
	 case 1: /* right top */
	    row = i - 1;
	    col = j + 1;
	    break;
	 case 2: /* right */
	    row = i;
	    col = j + 1;
	    break;
	 case 3: /* right bottom */
	    row = i + 1;
	    col = j + 1;
	    break;
	 case 4: /* bottom */
	    row = i + 1;
	    col = j;
	    break;
	 case 5: /* left bottom */
	    row = i + 1;
	    col = j - 1;
	    break;
	 case 6: /* left */
	    row = i;
	    col = j - 1;
	    break;
	 case 7: /* left top */
	    row = i - 1;
	    col = j - 1;
	    break;
	 default:
	    printf("Error!");
	    return 0;
      }
      if(row &lt; 0 || col &lt; 0 || row &gt;= ROWS || col &gt;= COLS || board[row][col] != '.') {
	 continue ;
      } else {
	 i = row;
	 j = col;
	 board[i][j] = ch;
	 ch ++;
      }
   }

   for(i = 0; i &lt; ROWS; i ++) {
      for(j = 0; j &lt; COLS; j ++) {
	 printf("%c ", board[i][j]);
      }
      printf("/n");
   }

   return 0;
}
```

