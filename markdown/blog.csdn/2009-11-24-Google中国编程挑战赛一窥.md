今天无意中看到了一个Google中国编程挑战赛的题, 感觉比较简单, 就顺便写了写.....呵呵.
 
原题在这个地方:[http://www.docin.com/p-7993053.html](http://www.docin.com/p-7993053.html)
 
题目:
在一行文字中, 光标移动可通过四个键完成, 左移和右移键, HOME键和END键,
将四键用L, R, H, E四个字母分别表示, 现在一行上写上若干个字母的组合
及本行共有多少文字, 问光标在什么位置. 最后求的是光标位置的值.
部件说明:
方法: get_persition
参数: str, int
 
 
 
```python
# -*- coding: UTF-8 -*-
'''
题目: 
在一行文字中, 光标移动可通过四个键完成, 左移和右移键, HOME键和END键, 
将四键用L, R, H, E四个字母分别表示, 现在一行上写上若干个字母的组合
及本行共有多少文字, 问光标在什么位置. 最后求的是光标位置的值.
部件说明:
方法: get_persition
参数: str, int
'''
import random

#===============================================================================
# left 光标向左移动一位之后的光标所在位置, 相当于方向键左键
# @param index: 光标当前位置
# @param max: 光标最大位置, 也就是这行文本有多少个字符
# @return: 移动之后的光标位置 
#===============================================================================
def left(index, max):
	tmp = index - 1
	return tmp if tmp &gt; 1 else 1

#===============================================================================
# right 光标向右移动一位之后的光标所在位置, 相当于方向键右键
# @param index: 光标当前位置
# @param max: 光标最大位置, 也就是这行文本有多少个字符
# @return: 移动之后的光标位置 
#===============================================================================
def right(index, max):
	tmp = index + 1
	return tmp if tmp &lt; max else max

#===============================================================================
# left 光标移动到首位, 相当于HOME键
# @param index: 光标当前位置
# @param max: 光标最大位置, 也就是这行文本有多少个字符
# @return: 移动之后的光标位置 
#===============================================================================
def home(index, max):
	return 1

#===============================================================================
# left 光标移动到末位, 相当于END键
# @param index: 光标当前位置
# @param max: 光标最大位置, 也就是这行文本有多少个字符
# @return: 移动之后的光标位置 
#===============================================================================
def end(index, max):
	return max

#===============================================================================
# signs是这个几个方法的别名. signs用来在生成测试字符串时标记.
# sign_function是别名跟方法的key-value配对. sign_function用来通过别名获取方法.
#===============================================================================
signs = ['l', 'r', 'h', 'e'] 
sign_function = {'l': left, 'r': right, 'h': home, 'e': end}

#===============================================================================
# get_string 用来获取指定长度的字符串. 返回的字符串只包含4个字符'l', 'r', 'h', 'e'
#===============================================================================
def get_string(amount):
	result = ''
	for i in range(amount):
		result += signs[random.randint(0, 3)]
	return result

#===============================================================================
# get_position 获取经过指定字符串标识的按键之后, 光标所在的位置.
# @param string: 代表按键序列的字符串, 测试时用get_string生成.
# @param length: 一行文本的长度. 光标的移动, 始终都是在同一行, 因此需要给出该行文本长度以确定光标具体位置.
# @return: 返回经过指定按键序列之后的光标位置.
#===============================================================================
def get_position(string, length):
	if not isinstance(string, str) or not isinstance(length, int):
		raise TypeError, '请提供正确的参数'
	#===========================================================================
	# 由于HOME键和END键会直接将光标移至行首或行末, 导致之前的按键序列无效.
	# 所以, 只有最后一个HOME或END键后面的l, r才是有效的操作. 由于取最后一个, 所以逆序效率应该更高.
	# 因此: 
	# 1. 逆序按键序列
	#===========================================================================
	tmp = reversed(string)
	#===========================================================================
	# 2. 逆序遍历, 并获取索引值
	#===========================================================================
	for index, value in enumerate(tmp):
		if value not in signs:
			raise ValueError, '您所提供的按键序列有误, 请提供只包含l, r, h, e四种操作的字符序列'
		#=======================================================================
		# 如果是l, r按键, 忽略.
		#=======================================================================
		if value is 'l' or value is 'r':
			continue
		#=======================================================================
		# 碰到一个h或e按键, 需要正向遍历
		# 相当于: 我们要在A和B之间, 找到我们的目标, 我们考虑发现目标离B可能比较近, 所以, 我们决定从B开始走, 
		# 现在, 我们发现了我们的目标, 我们就要带上它一起在返回B了.
		# 这里正向遍历那些有效的按键序列, 并调用对应的方法, 来计算光标位置.
		#=======================================================================
		else:
			string_length = len(string)
			start = string_length - index
			position = 1 if value is 'h' else length
			substring = string[start:]
			for key in substring:
				position = sign_function[key](position, length)
			break
	return position

if __name__ == '__main__':
	test = get_string(136)
	print test
	print get_position(test, 3999)

```

