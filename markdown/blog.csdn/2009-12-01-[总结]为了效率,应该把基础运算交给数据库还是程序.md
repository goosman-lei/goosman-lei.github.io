原贴地址:[点击进入](http://topic.csdn.net/u/20091129/19/de9a1ed7-2693-4803-a926-ed0b3943b770.html)
 
[[讨论]为了效率,应该把基础运算交给数据库还是程序?](http://topic.csdn.net/u/20091129/19/de9a1ed7-2693-4803-a926-ed0b3943b770.html)
 
今天, 帖子回复了100了, 对目前各位的回复做一个总结.
 
首先根据最下面的那些测试数据, 做出一个结论:
sum之类的数学运算(其他的我没测, 需要请自己测试), 一定用数据库去处理, 处理50万条有2000倍的差距, 这个差距一直到处理十条才被勉强抹平
位运算: 千条以内, 都可以用程序来处理, 更少比如几十条, 可能程序还会占优势.   数据量一上去, 还是要用数据库.
count类的统计运算, 100条左右可以考虑程序处理.
 
上面的结论很牵强. 问题所在都在于将大量的数据load到内存中去了, 我相信之所以产生如此大的差距, 多半是由于内存的关系.   所以, 在不需要对参与运算的数据做其他程序级的处理的时候, 建议都把他放到数据库中吧.(这里没有涉及存储过程等内容...)
 
 
从帖子中整理了大概下面这些观点....
1. 简单运算交给数据库, 复杂运算交给程序
2. 谁空闲谁处理
3. 数据库只做数据提取
4. 先取出数据再进行操作，还不如将他丢给数据库，省下了数据交换的时间
5. 没有听说利用数据库进行多线程计算、网格计算、CUDA计算的例子
6. 返回一套记录和多条记录是有差距的(40楼)
 
首先说说经过测试之后我的看法:
2. 谁空闲谁处理:
非常赞同, 在条件允许的情况下, 在不违背下面经过测试的性能对比数据前提下, 加一个转发是合适的, 类似服务器的负载均衡一样, 在程序中也处理一个访问控制来决定由谁来处理.
1, 3, 4:  第三条的观点经过测试几乎可以认定是错的, 原因是因为第六条..返回一套记录和多条记录是有差距的, 并且在海量数据情况下, 差距非常明显.
5. 没有这方面的经验, 不好做出评论.
6. 一语点醒梦中人.
 
下面是我的测试过程及数据
 
测试环境: 2.0GHz CPU, 2G物理内存, mysql5.0
数据量: 一千万
 
代码(最近在学python, 感觉方便就用了它...呵呵):
生成测试数据:

```python
#!/usr/bin/env python
# -*- coding: UTF-8 -*-
'''
@author: selfimpr
@blog: http://blog.csdn.net/lgg201
@mail: lgg860911@yahoo.com.cn
@date: 2009-12-1
'''
from MySQLdb import *
import random

def getrow(i):
    return 'username%d' % i, 'password%d' % i, random.randint(0, i)

def getconn():
    return connect(host = 'localhost', user = 'root', passwd = 'root', db = 'test')

def insertTest(amount):
    conn = getconn()
    cursor = conn.cursor()
    for i in range(1, amount):
        cursor.execute("INSERT INTO user(username, password, score) VALUES('%s', '%s', %d)" % getrow(i))
        if i % 100 == 0:
            conn.commit()
    cursor.close()
    conn.commit()
    conn.close()
    
if __name__ == '__main__':
    insertTest(10000000)

```

 
测试代码:
主要测试了统计函数, 简单数学运算, 位运算.....产生问题的集中原因就是因为帖子40楼所说, 返回一套数据和多条数据之间有差距.

```python
#!/usr/bin/env python
# -*- coding: UTF-8 -*-
'''
@author: selfimpr
@blog: http://blog.csdn.net/lgg201
@mail: lgg860911@yahoo.com.cn
@date: 2009-12-1
准备进行的测试项:
1. count()
2. 位运算
3. 简单运算
'''
from test_data import *
import time

def count_by_db():
    try:
        conn = getconn()
        cursor = conn.cursor()
        cursor.execute('SELECT COUNT(*) FROM user WHERE id &lt; 1000000')
        return cursor.fecthone()
    except Exception, e:
        conn.rollback()
    finally:
        cursor.close()
        conn.commit()
        conn.close()

def count_by_program():
    try:
        conn = getconn()
        cursor = conn.cursor()
        #内存有限, 只查个id吧.
        cursor.execute('SELECT id FROM user WHERE id &lt; 1000000')
        return len(cursor.fecthall())
    except Exception, e:
        conn.rollback()
    finally:
        cursor.close()
        conn.commit()
        conn.close()

def bit_by_db():
    try:
        conn = getconn()
        cursor = conn.cursor()
        #内存有限, 只查个id吧.
        cursor.execute('SELECT id ^ score FROM user WHERE id &lt; 1000000')
        return cursor.fecthall()
    except Exception, e:
        conn.rollback()
    finally:
        cursor.close()
        conn.commit()
        conn.close()

def bit_by_program():
    try:
        conn = getconn()
        cursor = conn.cursor()
        #内存有限, 只查个id吧.
        cursor.execute('SELECT id, score FROM user WHERE id &lt; 1000000')
        results = cursor.fecthall()
        results = [results[0] ^ results[1] for result in results]
        return results
    except Exception, e:
        conn.rollback()
    finally:
        cursor.close()
        conn.commit()
        conn.close()

def sum_by_db():
    try:
        conn = getconn()
        cursor = conn.cursor()
        #内存有限, 只查个id吧.
        cursor.execute('SELECT sum(id, score) FROM user WHERE id &lt; 1000000')
        return cursor.fecthall()
    except Exception, e:
        conn.rollback()
    finally:
        cursor.close()
        conn.commit()
        conn.close()


def sum_by_program():
    try:
        conn = getconn()
        cursor = conn.cursor()
        #内存有限, 只查个id吧.
        cursor.execute('SELECT id, score FROM user WHERE id &lt; 1000000')
        results = cursor.fecthall()
        results = [results[0] + results[1] for result in results]
        return results
    except Exception, e:
        conn.rollback()
    finally:
        cursor.close()
        conn.commit()
        conn.close()

def test(func, times):
    sum = 0
    for i in range(times):
        begin = time.time()
        func()
        total = time.time() - begin
        sum += total
        print sum
    return float(sum) / times
        

if __name__ == '__main__':
    f = open('c://test.txt', 'a')
    print &gt;&gt; f, 'count_by_db(100): %s' % test(count_by_db, 100)
    print &gt;&gt; f, 'count_by_program(100): %s' % test(count_by_program, 100)
    print &gt;&gt; f, 'bit_by_db(100): %s' % test(bit_by_db, 100)
    print &gt;&gt; f, 'bit_by_program(100): %s' % test(bit_by_program, 100)
    print &gt;&gt; f, 'sum_by_db(100): %s' % test(sum_by_db, 100)
    print &gt;&gt; f, 'sum_by_program(100): %s' % test(sum_by_program, 100)
    f.close()
```
  
 
下面是几组测试结果(每组测试数据都会运行100次然后求平均时间):
第一组: 从1000万条中查询50万条的处理
count_by_db(100): 0.256400001049                                        6倍左右
count_by_program(100): 1.63265999794
bit_by_db(100): 1.59203000069                                               1.3倍左右
bit_by_program(100): 2.06858999968
sum_by_db(100): 0.00171999931335                                       1000倍
sum_by_program(100): 2.00844000101
 
可以很明显的看出, 这些运算都应该放入到数据库中处理.
 
第二组: 从1000万条中查询1万条的处理
count_by_db(100): 0.00703000068665                                      4倍左右
count_by_program(100): 0.0295299983025
bit_by_db(100): 0.0298400020599                                             1.25倍左右                             
bit_by_program(100): 0.036099998951
sum_by_db(100): 0.00155999898911                                         20倍以上
sum_by_program(100): 0.0357800006866
 
第三组: 从1000万条中查询1000条:
count_by_db(100): 0.00266000032425                                       2倍左右
count_by_program(100): 0.00514999866486
bit_by_db(100): 0.0053200006485                                              1.2倍左右
bit_by_program(100): 0.00608999967575
sum_by_db(100): 0.00171999931335                                          3.5倍左右
sum_by_program(100): 0.00609000205994
 
第四组: 从1000万条中查询100条(呵呵, 数据少, 就让多跑了几次):
count_by_db(100): 0.00219000101089                                         综合三次, 相差不大, 数据库处理略占优势
count_by_program(100): 0.0021799993515
bit_by_db(100): 0.00203999996185                                              综合三次, 相差不大, 数据库处理略占优势
bit_by_program(100): 0.00203000068665
sum_by_db(100): 0.00156000137329                                           综合三次,  平均在1.5左右
sum_by_program(100): 0.00233999967575
 
count_by_db(100): 0.00186999797821
count_by_program(100): 0.00235000133514
bit_by_db(100): 0.00202999830246
bit_by_program(100): 0.00218000173569
sum_by_db(100): 0.00124999761581
sum_by_program(100): 0.00218000411987
 
count_by_db(100): 0.00202999830246
count_by_program(100): 0.00219000101089
bit_by_db(100): 0.0021799993515
bit_by_program(100): 0.00219000101089
sum_by_db(100): 0.00155999898911
sum_by_program(100): 0.00219000101089
 
 
第五组: 1000万数据中取10条处理:
count_by_db(100): 0.00219000101089                                 不相上下, 程序可能会略占优势
count_by_program(100): 0.0018799996376
bit_by_db(100): 0.0018700003624                                        不相上下, 程序可能会略占优势
bit_by_program(100): 0.0018799996376
sum_by_db(100): 0.00155999898911                                    程序依然没有讨到便宜
sum_by_program(100): 0.00172000169754
 
count_by_db(100): 0.00154999732971
count_by_program(100): 0.0018799996376
bit_by_db(100): 0.0018700003624
bit_by_program(100): 0.00172000169754
sum_by_db(100): 0.00140999794006
sum_by_program(100): 0.00156999826431
 
count_by_db(100): 0.00202999830246
count_by_program(100): 0.0018700003624
bit_by_db(100): 0.0018799996376
bit_by_program(100): 0.00171999931335
sum_by_db(100): 0.0015700006485
sum_by_program(100): 0.00156000137329
 
 
 
