
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="goosman-lei的博客">
    <meta name="keywords" content="PHP Web开发,PHP,PHP 框架,高可用,分布式">

    <title>基于mysql的分页程序完全解决方案含普通分页分段分页原始分页微博的since_id类分页- By Goosman-lei(goosman.lei@gmail.com</title>

    <!-- Styles -->
    <link href="http://static-cdn.tec-inf.com/css/theDocs.all.min.css" rel="stylesheet">
    <link href="http://static-cdn.tec-inf.com/css/theDocs.css" rel="stylesheet">
    <link href="http://static-cdn.tec-inf.com/css/custom.css" rel="stylesheet">

    <!-- Fonts -->
    <link href='http://fonts.googleapis.com/css?family=Raleway:100,300,400,500%7CLato:300,400' rel='stylesheet' type='text/css'>

    <!-- Favicons -->
    <link rel="apple-touch-icon" href="http://static-cdn.tec-inf.com/apple-touch-icon.png">
    <link rel="icon" href="http://static-cdn.tec-inf.com/img/favicon.ico">

    <!-- Github Buttons. Place this tag in your head or just before your close body tag. -->
    <script async defer src="https://buttons.github.io/buttons.js"></script>
  </head>

  <body>

    <header class="site-header">

      <!-- Top navbar & branding -->
      <nav class="navbar navbar-default">
        <div class="container">

          <!-- Toggle buttons and brand -->
          <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar" aria-expanded="true" aria-controls="navbar">
              <span class="glyphicon glyphicon-option-vertical"></span>
            </button>

            <button type="button" class="navbar-toggle for-sidebar" data-toggle="offcanvas">
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>

            <a class="navbar-brand" href="">Goosman.lei</a>
          </div>
          <!-- END Toggle buttons and brand -->

          <!-- Top navbar -->
          <div id="navbar" class="navbar-collapse collapse" aria-expanded="true" role="banner">
            <ul class="nav navbar-nav navbar-right">
                              <li class=""><a href="/ice">Ice</a></li>
                              <li class=" active"><a href="/blog-history">CSDN-BLOG</a></li>
                              <li class="hero"><a href="mailto:goosman.lei@gmail.com">Contact</a></li>
                          </ul>
          </div>
          <!-- END Top navbar -->

        </div>
      </nav>
      <!-- END Top navbar & branding -->
      
    </header>


    <main class="container">
      <div class="row">

        <!-- Sidebar -->
        <aside class="col-md-3 col-sm-3 sidebar">
<a class="github-button" href="https://github.com/goosman-lei" data-style="mega" data-count-href="/goosman-lei/followers" data-count-api="/users/goosman-lei#followers" data-count-aria-label="# followers on GitHub" aria-label="Follow @goosman-lei on GitHub">Follow @goosman-lei</a><br />

<!-- TODO 解递归当场遍历出树结构菜单 -->
<ul class="sidenav">
  <li><a href="/blog-history/2016/06/[分享]面向中大型应用的PHPWeb开发框架Ice.html">2016年</a>
  <ul>
    <li><a href="/blog-history/2016/06/[分享]面向中大型应用的PHPWeb开发框架Ice.html">06月</a>
    <ul>
      <li><a href="/blog-history/2016/06/[分享]面向中大型应用的PHPWeb开发框架Ice.html">[分享]面向中大型应用的PHPWeb开发框架Ice</a>
    </ul></li>
  </ul></li>
  <li><a href="/blog-history/2013/06/[翻译][php扩展开发和嵌入式]第20章-php的高级嵌入式.html">2013年</a>
  <ul>
    <li><a href="/blog-history/2013/06/[翻译][php扩展开发和嵌入式]第20章-php的高级嵌入式.html">06月</a>
    <ul>
      <li><a href="/blog-history/2013/06/[翻译][php扩展开发和嵌入式]第20章-php的高级嵌入式.html">[翻译][php扩展开发和嵌入式]第20章-php的高级嵌入式</a>
      <li><a href="/blog-history/2013/06/[翻译][php扩展开发和嵌入式]第19章-设置宿主环境.html">[翻译][php扩展开发和嵌入式]第19章-设置宿主环境</a>
      <li><a href="/blog-history/2013/06/[翻译][php扩展开发和嵌入式]第18章-php的扩展自动生成.html">[翻译][php扩展开发和嵌入式]第18章-php的扩展自动生成</a>
      <li><a href="/blog-history/2013/06/[翻译][php扩展开发和嵌入式]第17章-php源代码的配置和链接.html">[翻译][php扩展开发和嵌入式]第17章-php源代码的配置和链接</a>
    </ul></li>
    <li><a href="/blog-history/2013/05/[翻译][php扩展开发和嵌入式]第16章-有趣的流.html">05月</a>
    <ul>
      <li><a href="/blog-history/2013/05/[翻译][php扩展开发和嵌入式]第16章-有趣的流.html">[翻译][php扩展开发和嵌入式]第16章-有趣的流</a>
      <li><a href="/blog-history/2013/05/[翻译][php扩展开发和嵌入式]第15章-php中流的实现.html">[翻译][php扩展开发和嵌入式]第15章-php中流的实现</a>
    </ul></li>
    <li><a href="/blog-history/2013/04/[翻译][php扩展开发和嵌入式]第14章-php中流的访问.html">04月</a>
    <ul>
      <li><a href="/blog-history/2013/04/[翻译][php扩展开发和嵌入式]第14章-php中流的访问.html">[翻译][php扩展开发和嵌入式]第14章-php中流的访问</a>
      <li><a href="/blog-history/2013/04/[翻译][php扩展开发和嵌入式]第13章-php的INI设置.html">[翻译][php扩展开发和嵌入式]第13章-php的INI设置</a>
      <li><a href="/blog-history/2013/04/[翻译][php扩展开发和嵌入式]第12章-php的启动过程.html">[翻译][php扩展开发和嵌入式]第12章-php的启动过程</a>
      <li><a href="/blog-history/2013/04/[翻译][php扩展开发和嵌入式]第11章-php5对象.html">[翻译][php扩展开发和嵌入式]第11章-php5对象</a>
      <li><a href="/blog-history/2013/04/[翻译][php扩展开发和嵌入式]第10章-php4的对象.html">[翻译][php扩展开发和嵌入式]第10章-php4的对象</a>
    </ul></li>
    <li><a href="/blog-history/2013/03/[翻译][php扩展开发和嵌入式]第9章-资源数据类型.html">03月</a>
    <ul>
      <li><a href="/blog-history/2013/03/[翻译][php扩展开发和嵌入式]第9章-资源数据类型.html">[翻译][php扩展开发和嵌入式]第9章-资源数据类型</a>
      <li><a href="/blog-history/2013/03/[翻译][php扩展开发和嵌入式]第8章-在数组和哈希表上工作.html">[翻译][php扩展开发和嵌入式]第8章-在数组和哈希表上工作</a>
      <li><a href="/blog-history/2013/03/[翻译][php扩展开发和嵌入式]第7章-接受参数.html">[翻译][php扩展开发和嵌入式]第7章-接受参数</a>
      <li><a href="/blog-history/2013/03/从1.5k到18k,一个程序员的5年成长之路.html">从1.5k到18k,一个程序员的5年成长之路</a>
    </ul></li>
    <li><a href="/blog-history/2013/02/[翻译][php扩展开发和嵌入式]第6章-返回值.html">02月</a>
    <ul>
      <li><a href="/blog-history/2013/02/[翻译][php扩展开发和嵌入式]第6章-返回值.html">[翻译][php扩展开发和嵌入式]第6章-返回值</a>
      <li><a href="/blog-history/2013/02/[翻译][php扩展开发和嵌入式]第5章-您的第一个扩展.html">[翻译][php扩展开发和嵌入式]第5章-您的第一个扩展</a>
      <li><a href="/blog-history/2013/02/[翻译][php扩展开发和嵌入式]第4章-安装构建环境.html">[翻译][php扩展开发和嵌入式]第4章-安装构建环境</a>
    </ul></li>
    <li><a href="/blog-history/2013/01/[翻译][php扩展开发和嵌入式]第3章-内存管理.html">01月</a>
    <ul>
      <li><a href="/blog-history/2013/01/[翻译][php扩展开发和嵌入式]第3章-内存管理.html">[翻译][php扩展开发和嵌入式]第3章-内存管理</a>
      <li><a href="/blog-history/2013/01/[翻译][php扩展开发和嵌入式]第2章-变量的里里外外.html">[翻译][php扩展开发和嵌入式]第2章-变量的里里外外</a>
      <li><a href="/blog-history/2013/01/[php内核bug]动态链接方式编译的扩展,扩展全局空间dtor导致coredump.html">[php内核bug]动态链接方式编译的扩展,扩展全局空间dtor导致coredump</a>
      <li><a href="/blog-history/2013/01/[翻译][php扩展开发和嵌入式]第1章-php的生命周期.html">[翻译][php扩展开发和嵌入式]第1章-php的生命周期</a>
      <li><a href="/blog-history/2013/01/[翻译][php扩展开发和嵌入式]第0章-译序.html">[翻译][php扩展开发和嵌入式]第0章-译序</a>
    </ul></li>
  </ul></li>
  <li><a href="/blog-history/2012/12/从N个数中选取最大的前10个[堆排序版].html">2012年</a>
  <ul>
    <li><a href="/blog-history/2012/12/从N个数中选取最大的前10个[堆排序版].html">12月</a>
    <ul>
      <li><a href="/blog-history/2012/12/从N个数中选取最大的前10个[堆排序版].html">从N个数中选取最大的前10个[堆排序版]</a>
      <li><a href="/blog-history/2012/12/从N个数中选取最大的前10个[php版].html">从N个数中选取最大的前10个[php版]</a>
      <li><a href="/blog-history/2012/12/从N个数中选取最大的前10个[C语言版].html">从N个数中选取最大的前10个[C语言版]</a>
    </ul></li>
    <li><a href="/blog-history/2012/11/php截取字符串保留完整xml标签.html">11月</a>
    <ul>
      <li><a href="/blog-history/2012/11/php截取字符串保留完整xml标签.html">php截取字符串保留完整xml标签</a>
    </ul></li>
    <li><a href="/blog-history/2012/10/[mysql-manual-5.5]7.1优化概览.html">10月</a>
    <ul>
      <li><a href="/blog-history/2012/10/[mysql-manual-5.5]7.1优化概览.html">[mysql-manual-5.5]7.1优化概览</a>
      <li><a href="/blog-history/2012/10/php-mysql扩展mysql_querymysql_unbuffered_query对比.html">php-mysql扩展mysql_querymysql_unbuffered_query对比</a>
      <li><a href="/blog-history/2012/10/简单游戏场景用户模拟.html">简单游戏场景用户模拟</a>
      <li><a href="/blog-history/2012/10/php-mysql扩展的mysql_connectmysql_pconnect比较.html">php-mysql扩展的mysql_connectmysql_pconnect比较</a>
      <li><a href="/blog-history/2012/10/模拟新浪微博自动登陆.html">模拟新浪微博自动登陆</a>
    </ul></li>
    <li><a href="/blog-history/2012/09/php-curl封装[避免上传文件二义性Bug].html">09月</a>
    <ul>
      <li><a href="/blog-history/2012/09/php-curl封装[避免上传文件二义性Bug].html">php-curl封装[避免上传文件二义性Bug]</a>
      <li><a href="/blog-history/2012/09/[漏洞]ThinkSNS严重漏洞--将全站崩溃.html">[漏洞]ThinkSNS严重漏洞--将全站崩溃</a>
      <li><a href="/blog-history/2012/09/无限递归树展示.html">无限递归树展示</a>
      <li><a href="/blog-history/2012/09/[快速记忆]C语言php的运算符优先级结合性.html">[快速记忆]C语言php的运算符优先级结合性</a>
    </ul></li>
    <li><a href="/blog-history/2012/07/基于mysql的分页程序完全解决方案含普通分页分段分页原始分页微博的since_id类分页.html">07月</a>
    <ul>
      <li><a href="/blog-history/2012/07/基于mysql的分页程序完全解决方案含普通分页分段分页原始分页微博的since_id类分页.html" class="active">基于mysql的分页程序完全解决方案含普通分页分段分页原始分页微博的since_id类分页</a>
    </ul></li>
    <li><a href="/blog-history/2012/06/[软件工程]一个故事,分析陷入焦油坑的软件项目.html">06月</a>
    <ul>
      <li><a href="/blog-history/2012/06/[软件工程]一个故事,分析陷入焦油坑的软件项目.html">[软件工程]一个故事,分析陷入焦油坑的软件项目</a>
      <li><a href="/blog-history/2012/06/输出整数类型边界值及其大小K&RTheCprogramminglanguage习题2-1.html">输出整数类型边界值及其大小K&RTheCprogramminglanguage习题2-1</a>
      <li><a href="/blog-history/2012/06/算法分析从N条成绩单信息选择M位不重复同学发奖.html">算法分析从N条成绩单信息选择M位不重复同学发奖</a>
    </ul></li>
    <li><a href="/blog-history/2012/04/ThinkPHPCore3.0源代码review文档.html">04月</a>
    <ul>
      <li><a href="/blog-history/2012/04/ThinkPHPCore3.0源代码review文档.html">ThinkPHPCore3.0源代码review文档</a>
    </ul></li>
  </ul></li>
  <li><a href="/blog-history/2011/12/正则表达式分析提取XMLXHTML标签属性.html">2011年</a>
  <ul>
    <li><a href="/blog-history/2011/12/正则表达式分析提取XMLXHTML标签属性.html">12月</a>
    <ul>
      <li><a href="/blog-history/2011/12/正则表达式分析提取XMLXHTML标签属性.html">正则表达式分析提取XMLXHTML标签属性</a>
      <li><a href="/blog-history/2011/12/封装的一个mysql_lib.php,主要是一个分页模型.html">封装的一个mysql_lib.php,主要是一个分页模型</a>
      <li><a href="/blog-history/2011/12/爱因斯坦的思考题.html">爱因斯坦的思考题</a>
      <li><a href="/blog-history/2011/12/从浏览器操作系统市场占有率分析国人.html">从浏览器操作系统市场占有率分析国人</a>
    </ul></li>
    <li><a href="/blog-history/2011/10/[php内核]----文件系统函数用于普通文件时的一些情况.html">10月</a>
    <ul>
      <li><a href="/blog-history/2011/10/[php内核]----文件系统函数用于普通文件时的一些情况.html">[php内核]----文件系统函数用于普通文件时的一些情况</a>
      <li><a href="/blog-history/2011/10/某地自动评论脚本备份.html">某地自动评论脚本备份</a>
      <li><a href="/blog-history/2011/10/使用alarm配合信号实现sleep.html">使用alarm配合信号实现sleep</a>
      <li><a href="/blog-history/2011/10/libmemcached一致性hash算法详解2----简化版的libmemcached一致性hash算法实现.html">libmemcached一致性hash算法详解2----简化版的libmemcached一致性hash算法实现</a>
      <li><a href="/blog-history/2011/10/libmemcached一致性hash算法详解1----php-memcached客户端一致性哈希与crc算法共用产生的bug分析.html">libmemcached一致性hash算法详解1----php-memcached客户端一致性哈希与crc算法共用产生的bug分析</a>
      <li><a href="/blog-history/2011/10/由信号集联想----位域授权模式的不限长扩展.html">由信号集联想----位域授权模式的不限长扩展</a>
    </ul></li>
    <li><a href="/blog-history/2011/09/PHP位域操作函数封装.html">09月</a>
    <ul>
      <li><a href="/blog-history/2011/09/PHP位域操作函数封装.html">PHP位域操作函数封装</a>
    </ul></li>
    <li><a href="/blog-history/2011/08/基于dup实现linux的dup2函数APUE练习题3.2.html">08月</a>
    <ul>
      <li><a href="/blog-history/2011/08/基于dup实现linux的dup2函数APUE练习题3.2.html">基于dup实现linux的dup2函数APUE练习题3.2</a>
    </ul></li>
    <li><a href="/blog-history/2011/07/日志分析工具（二分法分段查找处理）.html">07月</a>
    <ul>
      <li><a href="/blog-history/2011/07/日志分析工具（二分法分段查找处理）.html">日志分析工具（二分法分段查找处理）</a>
      <li><a href="/blog-history/2011/07/从dl函数分析PHP模块开发.html">从dl函数分析PHP模块开发</a>
    </ul></li>
    <li><a href="/blog-history/2011/04/php中的引用传值分析.html">04月</a>
    <ul>
      <li><a href="/blog-history/2011/04/php中的引用传值分析.html">php中的引用传值分析</a>
    </ul></li>
    <li><a href="/blog-history/2011/03/phppcre正则表达式完全教程----pcre官方文档.html">03月</a>
    <ul>
      <li><a href="/blog-history/2011/03/phppcre正则表达式完全教程----pcre官方文档.html">phppcre正则表达式完全教程----pcre官方文档</a>
      <li><a href="/blog-history/2011/03/Ubuntu中利用Grub2修复移动硬盘引导.html">Ubuntu中利用Grub2修复移动硬盘引导</a>
    </ul></li>
    <li><a href="/blog-history/2011/02/PHP包含文件requireincluderequire_onceinclude_once__autoloadspl_autoload_xxx分析总结.html">02月</a>
    <ul>
      <li><a href="/blog-history/2011/02/PHP包含文件requireincluderequire_onceinclude_once__autoloadspl_autoload_xxx分析总结.html">PHP包含文件requireincluderequire_onceinclude_once__autoloadspl_autoload_xxx分析总结</a>
      <li><a href="/blog-history/2011/02/javascript中的继承,找回丢失的constructor.html">javascript中的继承,找回丢失的constructor</a>
      <li><a href="/blog-history/2011/02/浏览器市场份额--世界范围IE大幅下滑,国内IE小幅下滑,chrome涨势稳定.html">浏览器市场份额--世界范围IE大幅下滑,国内IE小幅下滑,chrome涨势稳定</a>
      <li><a href="/blog-history/2011/02/PHP操作符优先级列表及一个优先级带来的灵异事件.html">PHP操作符优先级列表及一个优先级带来的灵异事件</a>
      <li><a href="/blog-history/2011/02/PHP中requirePKrequire_once,构建自己的高效require_once10倍的性能提升.html">PHP中requirePKrequire_once,构建自己的高效require_once10倍的性能提升</a>
    </ul></li>
    <li><a href="/blog-history/2011/01/php5.3新增的闭包语法介绍functionuse{}.html">01月</a>
    <ul>
      <li><a href="/blog-history/2011/01/php5.3新增的闭包语法介绍functionuse{}.html">php5.3新增的闭包语法介绍functionuse{}</a>
      <li><a href="/blog-history/2011/01/与PHP5.3.5的战斗----记php5.3.5安装过程.html">与PHP5.3.5的战斗----记php5.3.5安装过程</a>
    </ul></li>
  </ul></li>
  <li><a href="/blog-history/2010/12/PHP在线实现工具linux下可用,windows未测试.html">2010年</a>
  <ul>
    <li><a href="/blog-history/2010/12/PHP在线实现工具linux下可用,windows未测试.html">12月</a>
    <ul>
      <li><a href="/blog-history/2010/12/PHP在线实现工具linux下可用,windows未测试.html">PHP在线实现工具linux下可用,windows未测试</a>
    </ul></li>
    <li><a href="/blog-history/2010/11/PHP利用共享内存构建计数器完成自增数值id生成--适用于网页游戏携带区服号的数值id生成.html">11月</a>
    <ul>
      <li><a href="/blog-history/2010/11/PHP利用共享内存构建计数器完成自增数值id生成--适用于网页游戏携带区服号的数值id生成.html">PHP利用共享内存构建计数器完成自增数值id生成--适用于网页游戏携带区服号的数值id生成</a>
      <li><a href="/blog-history/2010/11/PHPMemcached客户端memcache，memcached比较.html">PHPMemcached客户端memcache，memcached比较</a>
      <li><a href="/blog-history/2010/11/PHPMemcached扩展安装.html">PHPMemcached扩展安装</a>
      <li><a href="/blog-history/2010/11/PHPMemcached客户端官方文档翻译.html">PHPMemcached客户端官方文档翻译</a>
      <li><a href="/blog-history/2010/11/PHP中利用pcntl进行多进程并发控制.html">PHP中利用pcntl进行多进程并发控制</a>
      <li><a href="/blog-history/2010/11/PHP中的uniqid在高并发下的重复问题.html">PHP中的uniqid在高并发下的重复问题</a>
      <li><a href="/blog-history/2010/11/jQuery及jQueryUI内存泄漏问题修复.html">jQuery及jQueryUI内存泄漏问题修复</a>
    </ul></li>
    <li><a href="/blog-history/2010/10/完善eclipse+pdt作php开发中的代码提示能力.html">10月</a>
    <ul>
      <li><a href="/blog-history/2010/10/完善eclipse+pdt作php开发中的代码提示能力.html">完善eclipse+pdt作php开发中的代码提示能力</a>
      <li><a href="/blog-history/2010/10/输出指定格式的数字矩阵2.html">输出指定格式的数字矩阵2</a>
      <li><a href="/blog-history/2010/10/输出指定格式的数字矩阵.html">输出指定格式的数字矩阵</a>
    </ul></li>
    <li><a href="/blog-history/2010/09/sessvars插件源代码解析----一款用window.name产生前台session存储的js插件.html">09月</a>
    <ul>
      <li><a href="/blog-history/2010/09/sessvars插件源代码解析----一款用window.name产生前台session存储的js插件.html">sessvars插件源代码解析----一款用window.name产生前台session存储的js插件</a>
      <li><a href="/blog-history/2010/09/sessvars插件中文文档----一款用window.name产生前台session存储的js插件.html">sessvars插件中文文档----一款用window.name产生前台session存储的js插件</a>
      <li><a href="/blog-history/2010/09/php中Apc和memcache缓存数据性能对比.html">php中Apc和memcache缓存数据性能对比</a>
      <li><a href="/blog-history/2010/09/递归删除utf8文件的bom头该bom头可能导致php产生意外输出.html">递归删除utf8文件的bom头该bom头可能导致php产生意外输出</a>
    </ul></li>
    <li><a href="/blog-history/2010/08/性能测试从零开始--读书笔记.html">08月</a>
    <ul>
      <li><a href="/blog-history/2010/08/性能测试从零开始--读书笔记.html">性能测试从零开始--读书笔记</a>
      <li><a href="/blog-history/2010/08/PHP扩展pcntl进程控制以及信号处理中文文档.html">PHP扩展pcntl进程控制以及信号处理中文文档</a>
      <li><a href="/blog-history/2010/08/PHP中利用pcntl实现多进程模拟多线程实例.html">PHP中利用pcntl实现多进程模拟多线程实例</a>
    </ul></li>
    <li><a href="/blog-history/2010/07/Mysql主从复制的配置双机互为主从.html">07月</a>
    <ul>
      <li><a href="/blog-history/2010/07/Mysql主从复制的配置双机互为主从.html">Mysql主从复制的配置双机互为主从</a>
      <li><a href="/blog-history/2010/07/基于PHP客户端的TokyoTyrantTCH,TCB,TCT,Memcache,Mysql性能测试测试脚本.html">基于PHP客户端的TokyoTyrantTCH,TCB,TCT,Memcache,Mysql性能测试测试脚本</a>
      <li><a href="/blog-history/2010/07/基于PHP客户端的TokyoTyrantTCH,TCB,TCT,Memcache,Mysql性能测试.html">基于PHP客户端的TokyoTyrantTCH,TCB,TCT,Memcache,Mysql性能测试</a>
    </ul></li>
    <li><a href="/blog-history/2010/06/TC官方文档翻译12----编码APITokyoCabinetTokyoTyarnt文档系列.html">06月</a>
    <ul>
      <li><a href="/blog-history/2010/06/TC官方文档翻译12----编码APITokyoCabinetTokyoTyarnt文档系列.html">TC官方文档翻译12----编码APITokyoCabinetTokyoTyarnt文档系列</a>
      <li><a href="/blog-history/2010/06/TC官方文档翻译11----文件操作APITokyoCabinetTokyoTyarnt文档系列.html">TC官方文档翻译11----文件操作APITokyoCabinetTokyoTyarnt文档系列</a>
      <li><a href="/blog-history/2010/06/TC官方文档翻译10----其他APITokyoCabinetTokyoTyarnt文档系列.html">TC官方文档翻译10----其他APITokyoCabinetTokyoTyarnt文档系列</a>
      <li><a href="/blog-history/2010/06/TC官方文档翻译09----内存池对象APITokyoCabinetTokyoTyarnt文档系列.html">TC官方文档翻译09----内存池对象APITokyoCabinetTokyoTyarnt文档系列</a>
      <li><a href="/blog-history/2010/06/TC官方文档翻译08----内存树数据库APITokyoCabinetTokyoTyarnt文档系列.html">TC官方文档翻译08----内存树数据库APITokyoCabinetTokyoTyarnt文档系列</a>
      <li><a href="/blog-history/2010/06/TC官方文档翻译07----内存HASH数据库APITokyoCabinetTokyoTyarnt文档系列.html">TC官方文档翻译07----内存HASH数据库APITokyoCabinetTokyoTyarnt文档系列</a>
      <li><a href="/blog-history/2010/06/TC官方文档翻译06----OrderedTree对象APITokyoCabinetTokyoTyarnt文档系列.html">TC官方文档翻译06----OrderedTree对象APITokyoCabinetTokyoTyarnt文档系列</a>
      <li><a href="/blog-history/2010/06/TC官方文档翻译05----HashMap对象APITokyoCabinetTokyoTyarnt文档系列.html">TC官方文档翻译05----HashMap对象APITokyoCabinetTokyoTyarnt文档系列</a>
      <li><a href="/blog-history/2010/06/TC官方文档翻译04----列表对象APITokyoCabinetTokyoTyarnt文档系列.html">TC官方文档翻译04----列表对象APITokyoCabinetTokyoTyarnt文档系列</a>
      <li><a href="/blog-history/2010/06/TC官方文档翻译03----可扩充字符串APITokyoCabinetTokyoTyarnt文档系列.html">TC官方文档翻译03----可扩充字符串APITokyoCabinetTokyoTyarnt文档系列</a>
      <li><a href="/blog-history/2010/06/TC官方文档翻译02----基础APITokyoCabinetTokyoTyarnt文档系列.html">TC官方文档翻译02----基础APITokyoCabinetTokyoTyarnt文档系列</a>
      <li><a href="/blog-history/2010/06/TC官方文档翻译01----TokyoCabinet简介TokyoCabinetTokyoTyarnt文档系列.html">TC官方文档翻译01----TokyoCabinet简介TokyoCabinetTokyoTyarnt文档系列</a>
      <li><a href="/blog-history/2010/06/IE7中onpropertychange引发的Stackoverflowatlinexxx问题解决.html">IE7中onpropertychange引发的Stackoverflowatlinexxx问题解决</a>
      <li><a href="/blog-history/2010/06/让jQuery的load方法可以接受ajax选项解决缓存等问题.html">让jQuery的load方法可以接受ajax选项解决缓存等问题</a>
      <li><a href="/blog-history/2010/06/正则表达式中的贪婪与非贪婪的性能问题.html">正则表达式中的贪婪与非贪婪的性能问题</a>
      <li><a href="/blog-history/2010/06/PHP+Mysql+jQuery+fullcalendar实现的微型公司内部订餐系统.html">PHP+Mysql+jQuery+fullcalendar实现的微型公司内部订餐系统</a>
    </ul></li>
    <li><a href="/blog-history/2010/05/扩展Javascript的String原型,添加汉字截取.html">05月</a>
    <ul>
      <li><a href="/blog-history/2010/05/扩展Javascript的String原型,添加汉字截取.html">扩展Javascript的String原型,添加汉字截取</a>
      <li><a href="/blog-history/2010/05/input标签的汉字长度限制.html">input标签的汉字长度限制</a>
    </ul></li>
    <li><a href="/blog-history/2010/04/HighPerformanceMySQL作者对TokyoTyrant做的性能测试benchmark.html">04月</a>
    <ul>
      <li><a href="/blog-history/2010/04/HighPerformanceMySQL作者对TokyoTyrant做的性能测试benchmark.html">HighPerformanceMySQL作者对TokyoTyrant做的性能测试benchmark</a>
      <li><a href="/blog-history/2010/04/PHP的TokyoTyrant扩展接口API文档PECL.html">PHP的TokyoTyrant扩展接口API文档PECL</a>
    </ul></li>
    <li><a href="/blog-history/2010/03/jQuery实现的Dialog支持模态和拖动.html">03月</a>
    <ul>
      <li><a href="/blog-history/2010/03/jQuery实现的Dialog支持模态和拖动.html">jQuery实现的Dialog支持模态和拖动</a>
      <li><a href="/blog-history/2010/03/css滤镜之light实现的灯光效果..html">css滤镜之light实现的灯光效果.</a>
      <li><a href="/blog-history/2010/03/CSS滤镜笔记------包含Light滤镜方法的使用.html">CSS滤镜笔记------包含Light滤镜方法的使用</a>
      <li><a href="/blog-history/2010/03/基于jQuery实现的焦点轮换效果.html">基于jQuery实现的焦点轮换效果</a>
      <li><a href="/blog-history/2010/03/jQuery.ui.1.7.2中文文档官方文档翻译.html">jQuery.ui.1.7.2中文文档官方文档翻译</a>
      <li><a href="/blog-history/2010/03/jQuery.ui.1.7.2-selectable中文文档.html">jQuery.ui.1.7.2-selectable中文文档</a>
      <li><a href="/blog-history/2010/03/jQuery.ui.1.7.2--Datepicker中文文档.html">jQuery.ui.1.7.2--Datepicker中文文档</a>
      <li><a href="/blog-history/2010/03/JavaScript中的正则替换.html">JavaScript中的正则替换</a>
    </ul></li>
    <li><a href="/blog-history/2010/02/Java-UrlRewrite中文官方文档.html">02月</a>
    <ul>
      <li><a href="/blog-history/2010/02/Java-UrlRewrite中文官方文档.html">Java-UrlRewrite中文官方文档</a>
      <li><a href="/blog-history/2010/02/Struts2整合Json插件时的一个隐蔽BUG-----struts2-json-plugin-2.1.8.html">Struts2整合Json插件时的一个隐蔽BUG-----struts2-json-plugin-2.1.8</a>
      <li><a href="/blog-history/2010/02/Javascript中可以接受参数的延时函数回调.html">Javascript中可以接受参数的延时函数回调</a>
      <li><a href="/blog-history/2010/02/python的闭包3.0之前及之后.html">python的闭包3.0之前及之后</a>
      <li><a href="/blog-history/2010/02/Sitemesh整合struts2使用多个装饰器非的BUG修正.html">Sitemesh整合struts2使用多个装饰器非的BUG修正</a>
    </ul></li>
    <li><a href="/blog-history/2010/01/SiteMesh官方文档翻译含Freemarker但不包括velocity部分.html">01月</a>
    <ul>
      <li><a href="/blog-history/2010/01/SiteMesh官方文档翻译含Freemarker但不包括velocity部分.html">SiteMesh官方文档翻译含Freemarker但不包括velocity部分</a>
      <li><a href="/blog-history/2010/01/通用的分页模型实现..html">通用的分页模型实现.</a>
      <li><a href="/blog-history/2010/01/Servlet中通过过滤器实现统一的手动编码解决中文乱码.html">Servlet中通过过滤器实现统一的手动编码解决中文乱码</a>
      <li><a href="/blog-history/2010/01/struts2的请求处理过程源码分析.html">struts2的请求处理过程源码分析</a>
      <li><a href="/blog-history/2010/01/Struts2中ActionMapping对象的构建过程.html">Struts2中ActionMapping对象的构建过程</a>
      <li><a href="/blog-history/2010/01/IOC的简单实现及其意义..html">IOC的简单实现及其意义.</a>
      <li><a href="/blog-history/2010/01/C语言中的offsetof宏定义在stddef.h头中.html">C语言中的offsetof宏定义在stddef.h头中</a>
      <li><a href="/blog-history/2010/01/生产者消费者问题之Java线程实现.html">生产者消费者问题之Java线程实现</a>
      <li><a href="/blog-history/2010/01/涂鸦你的CSDN博客.html">涂鸦你的CSDN博客</a>
    </ul></li>
  </ul></li>
  <li><a href="/blog-history/2009/12/PHP在线实现工具linux下可用,windows未测试.html">2009年</a>
  <ul>
    <li><a href="/blog-history/2009/12/PHP在线实现工具linux下可用,windows未测试.html">12月</a>
    <ul>
      <li><a href="/blog-history/2009/12/PHP在线实现工具linux下可用,windows未测试.html">PHP在线实现工具linux下可用,windows未测试</a>
    </ul></li>
    <li><a href="/blog-history/2009/11/PHP利用共享内存构建计数器完成自增数值id生成--适用于网页游戏携带区服号的数值id生成.html">11月</a>
    <ul>
      <li><a href="/blog-history/2009/11/PHP利用共享内存构建计数器完成自增数值id生成--适用于网页游戏携带区服号的数值id生成.html">PHP利用共享内存构建计数器完成自增数值id生成--适用于网页游戏携带区服号的数值id生成</a>
      <li><a href="/blog-history/2009/11/PHPMemcached客户端memcache，memcached比较.html">PHPMemcached客户端memcache，memcached比较</a>
      <li><a href="/blog-history/2009/11/PHPMemcached扩展安装.html">PHPMemcached扩展安装</a>
      <li><a href="/blog-history/2009/11/PHPMemcached客户端官方文档翻译.html">PHPMemcached客户端官方文档翻译</a>
      <li><a href="/blog-history/2009/11/PHP中利用pcntl进行多进程并发控制.html">PHP中利用pcntl进行多进程并发控制</a>
      <li><a href="/blog-history/2009/11/PHP中的uniqid在高并发下的重复问题.html">PHP中的uniqid在高并发下的重复问题</a>
      <li><a href="/blog-history/2009/11/jQuery及jQueryUI内存泄漏问题修复.html">jQuery及jQueryUI内存泄漏问题修复</a>
    </ul></li>
    <li><a href="/blog-history/2009/10/完善eclipse+pdt作php开发中的代码提示能力.html">10月</a>
    <ul>
      <li><a href="/blog-history/2009/10/完善eclipse+pdt作php开发中的代码提示能力.html">完善eclipse+pdt作php开发中的代码提示能力</a>
      <li><a href="/blog-history/2009/10/输出指定格式的数字矩阵2.html">输出指定格式的数字矩阵2</a>
      <li><a href="/blog-history/2009/10/输出指定格式的数字矩阵.html">输出指定格式的数字矩阵</a>
    </ul></li>
    <li><a href="/blog-history/2009/09/sessvars插件源代码解析----一款用window.name产生前台session存储的js插件.html">09月</a>
    <ul>
      <li><a href="/blog-history/2009/09/sessvars插件源代码解析----一款用window.name产生前台session存储的js插件.html">sessvars插件源代码解析----一款用window.name产生前台session存储的js插件</a>
      <li><a href="/blog-history/2009/09/sessvars插件中文文档----一款用window.name产生前台session存储的js插件.html">sessvars插件中文文档----一款用window.name产生前台session存储的js插件</a>
      <li><a href="/blog-history/2009/09/php中Apc和memcache缓存数据性能对比.html">php中Apc和memcache缓存数据性能对比</a>
      <li><a href="/blog-history/2009/09/递归删除utf8文件的bom头该bom头可能导致php产生意外输出.html">递归删除utf8文件的bom头该bom头可能导致php产生意外输出</a>
    </ul></li>
    <li><a href="/blog-history/2009/08/性能测试从零开始--读书笔记.html">08月</a>
    <ul>
      <li><a href="/blog-history/2009/08/性能测试从零开始--读书笔记.html">性能测试从零开始--读书笔记</a>
      <li><a href="/blog-history/2009/08/PHP扩展pcntl进程控制以及信号处理中文文档.html">PHP扩展pcntl进程控制以及信号处理中文文档</a>
      <li><a href="/blog-history/2009/08/PHP中利用pcntl实现多进程模拟多线程实例.html">PHP中利用pcntl实现多进程模拟多线程实例</a>
    </ul></li>
    <li><a href="/blog-history/2009/07/Mysql主从复制的配置双机互为主从.html">07月</a>
    <ul>
      <li><a href="/blog-history/2009/07/Mysql主从复制的配置双机互为主从.html">Mysql主从复制的配置双机互为主从</a>
      <li><a href="/blog-history/2009/07/基于PHP客户端的TokyoTyrantTCH,TCB,TCT,Memcache,Mysql性能测试测试脚本.html">基于PHP客户端的TokyoTyrantTCH,TCB,TCT,Memcache,Mysql性能测试测试脚本</a>
      <li><a href="/blog-history/2009/07/基于PHP客户端的TokyoTyrantTCH,TCB,TCT,Memcache,Mysql性能测试.html">基于PHP客户端的TokyoTyrantTCH,TCB,TCT,Memcache,Mysql性能测试</a>
    </ul></li>
    <li><a href="/blog-history/2009/06/TC官方文档翻译12----编码APITokyoCabinetTokyoTyarnt文档系列.html">06月</a>
    <ul>
      <li><a href="/blog-history/2009/06/TC官方文档翻译12----编码APITokyoCabinetTokyoTyarnt文档系列.html">TC官方文档翻译12----编码APITokyoCabinetTokyoTyarnt文档系列</a>
      <li><a href="/blog-history/2009/06/TC官方文档翻译11----文件操作APITokyoCabinetTokyoTyarnt文档系列.html">TC官方文档翻译11----文件操作APITokyoCabinetTokyoTyarnt文档系列</a>
      <li><a href="/blog-history/2009/06/TC官方文档翻译10----其他APITokyoCabinetTokyoTyarnt文档系列.html">TC官方文档翻译10----其他APITokyoCabinetTokyoTyarnt文档系列</a>
      <li><a href="/blog-history/2009/06/TC官方文档翻译09----内存池对象APITokyoCabinetTokyoTyarnt文档系列.html">TC官方文档翻译09----内存池对象APITokyoCabinetTokyoTyarnt文档系列</a>
      <li><a href="/blog-history/2009/06/TC官方文档翻译08----内存树数据库APITokyoCabinetTokyoTyarnt文档系列.html">TC官方文档翻译08----内存树数据库APITokyoCabinetTokyoTyarnt文档系列</a>
      <li><a href="/blog-history/2009/06/TC官方文档翻译07----内存HASH数据库APITokyoCabinetTokyoTyarnt文档系列.html">TC官方文档翻译07----内存HASH数据库APITokyoCabinetTokyoTyarnt文档系列</a>
      <li><a href="/blog-history/2009/06/TC官方文档翻译06----OrderedTree对象APITokyoCabinetTokyoTyarnt文档系列.html">TC官方文档翻译06----OrderedTree对象APITokyoCabinetTokyoTyarnt文档系列</a>
      <li><a href="/blog-history/2009/06/TC官方文档翻译05----HashMap对象APITokyoCabinetTokyoTyarnt文档系列.html">TC官方文档翻译05----HashMap对象APITokyoCabinetTokyoTyarnt文档系列</a>
      <li><a href="/blog-history/2009/06/TC官方文档翻译04----列表对象APITokyoCabinetTokyoTyarnt文档系列.html">TC官方文档翻译04----列表对象APITokyoCabinetTokyoTyarnt文档系列</a>
      <li><a href="/blog-history/2009/06/TC官方文档翻译03----可扩充字符串APITokyoCabinetTokyoTyarnt文档系列.html">TC官方文档翻译03----可扩充字符串APITokyoCabinetTokyoTyarnt文档系列</a>
      <li><a href="/blog-history/2009/06/TC官方文档翻译02----基础APITokyoCabinetTokyoTyarnt文档系列.html">TC官方文档翻译02----基础APITokyoCabinetTokyoTyarnt文档系列</a>
      <li><a href="/blog-history/2009/06/TC官方文档翻译01----TokyoCabinet简介TokyoCabinetTokyoTyarnt文档系列.html">TC官方文档翻译01----TokyoCabinet简介TokyoCabinetTokyoTyarnt文档系列</a>
      <li><a href="/blog-history/2009/06/IE7中onpropertychange引发的Stackoverflowatlinexxx问题解决.html">IE7中onpropertychange引发的Stackoverflowatlinexxx问题解决</a>
      <li><a href="/blog-history/2009/06/让jQuery的load方法可以接受ajax选项解决缓存等问题.html">让jQuery的load方法可以接受ajax选项解决缓存等问题</a>
      <li><a href="/blog-history/2009/06/正则表达式中的贪婪与非贪婪的性能问题.html">正则表达式中的贪婪与非贪婪的性能问题</a>
      <li><a href="/blog-history/2009/06/PHP+Mysql+jQuery+fullcalendar实现的微型公司内部订餐系统.html">PHP+Mysql+jQuery+fullcalendar实现的微型公司内部订餐系统</a>
    </ul></li>
    <li><a href="/blog-history/2009/05/扩展Javascript的String原型,添加汉字截取.html">05月</a>
    <ul>
      <li><a href="/blog-history/2009/05/扩展Javascript的String原型,添加汉字截取.html">扩展Javascript的String原型,添加汉字截取</a>
      <li><a href="/blog-history/2009/05/input标签的汉字长度限制.html">input标签的汉字长度限制</a>
    </ul></li>
    <li><a href="/blog-history/2009/04/HighPerformanceMySQL作者对TokyoTyrant做的性能测试benchmark.html">04月</a>
    <ul>
      <li><a href="/blog-history/2009/04/HighPerformanceMySQL作者对TokyoTyrant做的性能测试benchmark.html">HighPerformanceMySQL作者对TokyoTyrant做的性能测试benchmark</a>
      <li><a href="/blog-history/2009/04/PHP的TokyoTyrant扩展接口API文档PECL.html">PHP的TokyoTyrant扩展接口API文档PECL</a>
    </ul></li>
    <li><a href="/blog-history/2009/03/jQuery实现的Dialog支持模态和拖动.html">03月</a>
    <ul>
      <li><a href="/blog-history/2009/03/jQuery实现的Dialog支持模态和拖动.html">jQuery实现的Dialog支持模态和拖动</a>
      <li><a href="/blog-history/2009/03/css滤镜之light实现的灯光效果..html">css滤镜之light实现的灯光效果.</a>
      <li><a href="/blog-history/2009/03/CSS滤镜笔记------包含Light滤镜方法的使用.html">CSS滤镜笔记------包含Light滤镜方法的使用</a>
      <li><a href="/blog-history/2009/03/基于jQuery实现的焦点轮换效果.html">基于jQuery实现的焦点轮换效果</a>
      <li><a href="/blog-history/2009/03/jQuery.ui.1.7.2中文文档官方文档翻译.html">jQuery.ui.1.7.2中文文档官方文档翻译</a>
      <li><a href="/blog-history/2009/03/jQuery.ui.1.7.2-selectable中文文档.html">jQuery.ui.1.7.2-selectable中文文档</a>
      <li><a href="/blog-history/2009/03/jQuery.ui.1.7.2--Datepicker中文文档.html">jQuery.ui.1.7.2--Datepicker中文文档</a>
      <li><a href="/blog-history/2009/03/JavaScript中的正则替换.html">JavaScript中的正则替换</a>
    </ul></li>
    <li><a href="/blog-history/2009/02/Java-UrlRewrite中文官方文档.html">02月</a>
    <ul>
      <li><a href="/blog-history/2009/02/Java-UrlRewrite中文官方文档.html">Java-UrlRewrite中文官方文档</a>
      <li><a href="/blog-history/2009/02/Struts2整合Json插件时的一个隐蔽BUG-----struts2-json-plugin-2.1.8.html">Struts2整合Json插件时的一个隐蔽BUG-----struts2-json-plugin-2.1.8</a>
      <li><a href="/blog-history/2009/02/Javascript中可以接受参数的延时函数回调.html">Javascript中可以接受参数的延时函数回调</a>
      <li><a href="/blog-history/2009/02/python的闭包3.0之前及之后.html">python的闭包3.0之前及之后</a>
      <li><a href="/blog-history/2009/02/Sitemesh整合struts2使用多个装饰器非的BUG修正.html">Sitemesh整合struts2使用多个装饰器非的BUG修正</a>
    </ul></li>
    <li><a href="/blog-history/2009/01/SiteMesh官方文档翻译含Freemarker但不包括velocity部分.html">01月</a>
    <ul>
      <li><a href="/blog-history/2009/01/SiteMesh官方文档翻译含Freemarker但不包括velocity部分.html">SiteMesh官方文档翻译含Freemarker但不包括velocity部分</a>
      <li><a href="/blog-history/2009/01/通用的分页模型实现..html">通用的分页模型实现.</a>
      <li><a href="/blog-history/2009/01/Servlet中通过过滤器实现统一的手动编码解决中文乱码.html">Servlet中通过过滤器实现统一的手动编码解决中文乱码</a>
      <li><a href="/blog-history/2009/01/struts2的请求处理过程源码分析.html">struts2的请求处理过程源码分析</a>
      <li><a href="/blog-history/2009/01/Struts2中ActionMapping对象的构建过程.html">Struts2中ActionMapping对象的构建过程</a>
      <li><a href="/blog-history/2009/01/IOC的简单实现及其意义..html">IOC的简单实现及其意义.</a>
      <li><a href="/blog-history/2009/01/C语言中的offsetof宏定义在stddef.h头中.html">C语言中的offsetof宏定义在stddef.h头中</a>
      <li><a href="/blog-history/2009/01/生产者消费者问题之Java线程实现.html">生产者消费者问题之Java线程实现</a>
      <li><a href="/blog-history/2009/01/涂鸦你的CSDN博客.html">涂鸦你的CSDN博客</a>
    </ul></li>
  </ul></li>
</ul>
        </aside>
        <!-- END Sidebar -->


        <!-- Main content -->
        <article class="col-md-9 col-sm-9 main-content" role="main">
          
          <header>
            <h1></h1>
            <p></p>
<ol class="toc">
</li></ol>

          </header>

          <section>
<p>Author: selfimpr
Blog: <a href="http://blog.csdn.net/lgg201">http://blog.csdn.net/lgg201</a>
Mail: <a href="mailto:goosman.lei@gmail.com">goosman.lei@gmail.com</a>
Copyright: 转载请注明出处</p>

<ol>
<li>下载:
本程序可自由修改, 自由分发, 可在<a href="http://download.csdn.net/user/lgg201%E4%B8%8B%E8%BD%BD">http://download.csdn.net/user/lgg201下载</a></li>
<li>分页的需求
信息的操纵和检索是当下互联网和企业信息系统承担的主要责任. 信息检索是从大量的数据中找到符合条件的数据以用户界面展现给用户.
符合条件的数据通常会有成千上万条, 而用户的单次信息接受量是很小的, 因此, 如果一次将所有符合用户条件的数据展现给用户, 对于多数场景, 其中大部分数据都是冗余的.
信息检索完成后, 是需要经过传输(从存储介质到应用程序)和相关计算(业务逻辑)的, 因此, 我们需要一种分段的信息检索机制来降低这种冗余.
分页应运而生.</li>
<li>分页的发展
基本的分页程序, 将数据按照每页记录数(page_size)将数据分为ceil(total_record / page_size)页, 第一次为用户展现第一段的数据, 后续的交互过程中, 用户可以选择到某一页对数据进行审阅.
后来, 主要是在微博应用出现后, 由于其信息变化很快, 而其特性为基于时间线增加数据, 这样, 基本的分页程序不能再满足需求了: a) 当获取下一页时, 数据集可能已经发生了很多变化, 翻页随时都可能导致数据重复或跳跃; b) 此类应用采用很多采用一屏展示多段数据的用户界面, 更加加重了数据重复/跳跃对用户体验的影响. 因此, 程序员们开始使用since_id的方式, 将下一次获取数据的点记录下来, 已减轻上述弊端.
在同一个用户界面, 通过用户阅读行为自动获取下一段/上一段数据的确比点击&quot;下一页&quot;按钮的用户体验要好, 但同样有弊端: a) 当用户已经到第100页时, 他要回到刚才感兴趣的第5页的信息时, 并不是很容易, 这其实是一条设计应用的规则, 我们不能让用户界面的单页屏数过多, 这样会降低用户体验; b) 单从数据角度看, 我们多次读取之间的间隔时间足够让数据发生一些变化, 在一次只展示一屏时, 我们很难发现这些问题(因此不影响用户体验),
然而当一页展示100屏数据时, 这种变化会被放大, 此时, 数据重复/跳跃的问题就会再次出现; c) 从程序的角度看, 将大量的数据放置在同一个用户界面, 必然导致用户界面的程序逻辑受到影响. 基于以上考虑, 目前应用已经开始对分页进行修正, 将一页所展示的屏数进行的限制, 同时加入了页码的概念, 另外也结合since_id的方式, 以达到用户体验最优, 同时保证数据逻辑的正确性(降低误差).</li>
<li>分页的讨论
感谢xp/jp/zq/lw四位同事的讨论, 基于多次讨论, 我们分析了分页程序的本质. 主要的结论点如下:
1) 分页的目的是为了分段读取数据
2) 能够进行分页的数据一定是有序的, 哪怕他是依赖数据库存储顺序. (这一点换一种说法更容易理解: 当数据集没有发生变化时, 同样的输入, 多次执行, 得到的输出顺序保持不变)
3) 所有的分段式数据读取, 要完全保证数据集的一致性, 必须保证数据集顺序的一致性, 即快照
4) 传统的分页, 分段式分页(每页内分为多段)归根结底是对数据集做一次切割, 映射到mysql的sql语法上, 就是根据输入求得limit子句, 适用场景为数据集变化频率低
5) since_id类分页, 其本质是假定已有数据无变化, 将数据集的某一个点的id(在数据集中可以绝对定位该数据的相关字段)提供给用户侧, 每次携带该id读取相应位置的数据, 以此模拟快照, 使用场景为数据集历史数据变化频率低, 新增数据频繁
6) 如果存在一个快照系统, 能够为每一个会话发起时的数据集产生一份快照数据, 那么一切问题都迎刃而解
7) 在没有快照系统的时候, 我们可以用since_id的方式限定数据范围, 模拟快照系统, 可以解决大多数问题
8) 要使用since_id方式模拟快照, 其数据集排序规则必须有能够唯一标识其每一个数据的字段(可能是复合的)</li>
<li>实现思路
1) 提供SQL的转换函数
2) 支持分段式分页(page, page_ping, ping, ping_size), 传统分页(page, page_size), 原始分页(offset-count), since_id分页(prev_id, next_id)
3) 分段式分页, 传统分页, 原始分页在底层均转换为原始分页处理</li>
<li>实现定义
ping_to_offset
输入:
page#请求页码, 范围: [1, total_page], 超过范围以边界计, 即0修正为1, total_page + 1修正为total_page
ping#请求段号, 范围: [1, page_ping], 超过范围以边界计, 即0修正为1, page_ping + 1修正为page_ping
page_ping#每页分段数, 范围: [1, 无穷]
count#要获取的记录数, 当前应用场景含义为: 每段记录数, 范围: [1, 无穷]
total_record#总记录数, 范围: [1, 无穷]
输出:
offset#偏移量
count#读取条数
offset_to_ping
输入:
offset#偏移量(必须按照count对齐, 即可以被count整除), 范围: [0, 无穷]
page_ping#每页分段数, 范围: [1, 无穷]
count#读取条数, 范围: [1, 无穷]
输出:
page#请求页码
ping#请求段号
page_ping#每页分段数
count#要获取的记录数, 当前应用场景含义为: 每段记录数
page_to_offset
输入:
page#请求页码, 范围: [1, total_page], 超过范围以边界计, 即0修正为1, total_page + 1修正为total_page
total_record#总记录数, 范围: [1, 无穷]
count#要获取的记录数, 当前应用场景含义为: 每页条数, 范围: [1, 无穷]
输出:
offset#偏移量
count#读取条数
offset_to_page
输入:
offset#偏移量(必须按照count对齐, 即可以被count整除), 范围: [0, 无穷]
count#读取条数, 范围: [1, 无穷]
输出:
page#请求页码
count#要获取的记录数, 当前应用场景含义为: 每页条数
sql_parser#将符合mysql语法规范的SQL语句解析得到各个组件
输入:
sql#要解析的sql语句
输出:
sql_components#SQL解析后的字段
sql_restore#将SQL语句组件集转换为SQL语句
输入:
sql_components#要还原的SQL语句组件集
输出:
sql#还原后的SQL语句
sql_to_count#将符合mysql语法规范的SELECT语句转换为获取计数
输入:
sql_components#要转换为查询计数的SQL语句组件集
alias#计数字段的别名
输出:
sql_components#转换后的查询计数SQL语句组件集
sql_add_offset
输入:
sql_components#要增加偏移的SQL语句组件集, 不允许存在LIMIT组件
offset#偏移量(必须按照count对齐, 即可以被count整除), 范围: [0, 无穷]
count#要获取的记录数, 范围: [1, 无穷]
输出:
sql_components#已增加LIMIT组件的SQL语句组件集
sql_add_since#增加since_id式的范围
输入:
sql_components#要增加范围限定的SQL语句组件集
prev_id#标记上一次请求得到的数据左边界
next_id#标记上一次请求得到的数据右边界
输出:
sql_components#增加since_id模拟快照的范围限定后的SQL语句组件集
datas_boundary#获取当前数据集的边界
输入:
sql_components#要读取的数据集对应的SQL语句组件集
datas#结果数据集
输出:
prev_id#当前数据集左边界
next_id#当前数据集右边界
mysql_paginate_query#执行分页支持的SQL语句
输入:
sql#要执行的业务SQL语句
offset#偏移量(必须按照count对齐, 即可以被count整除), 范围: [0, 无穷]
count#读取条数, 范围: [1, 无穷]
prev_id#标记上一次请求得到的数据左边界
next_id#标记上一次请求得到的数据右边界
输出:
datas#查询结果集
offset#偏移量
count#读取条数
prev_id#当前数据集的左边界
next_id#当前数据集的右边界</li>
<li>实现的执行流程
分段式分页应用(page, ping, page_ping, count):
total_record= sql_to_count(sql);
(offset, count)= ping_to_offset(page, ping, page_ping, count, total_record)
(datas, offset, count)= mysql_paginate_query(sql, offset, count, NULL, NULL);
(page, ping, page_ping, total_record, count)= offset_to_ping(offset, page_ping, count, total_record);
return (datas, page, ping, page_ping, total_record, count);
传统分页应用(page, count):
total_record= sql_to_count(sql);
(offset, count)= page_to_offset(page, count, total_record)
(datas, offset, count)= mysql_paginate_query(sql, offset, count, NULL, NULL);
(page, total_record, count)= offset_to_page(offset, count, total_record);
return (datas, page, total_record, count);
since_id分页应用(count, prev_id, next_id):
total_record= sql_to_count(sql);
(datas, offset, count, prev_id, next_id)= mysql_paginate_query(sql, NULL, count, prev_id, next_id);
return (count, prev_id, next_id);
复合型分段式分页应用(page, ping, page_ping, count, prev_id, next_id):
total_record= sql_to_count(sql);
(offset, count)= ping_to_offset(page, ping, page_ping, count, total_record)
(datas, offset, count, prev_id, next_id)= mysql_paginate_query(sql, offset, count, prev_id, next_id);
(page, ping, page_ping, total_record, count)= offset_to_ping(offset, page_ping, count, total_record);
return (datas, page, ping, page_ping, total_record, count, prev_id, next_id);
复合型传统分页应用(page, count, prev_id, next_id):
total_record= sql_to_count(sql);
(offset, count)= page_to_offset(page, count, total_record)
(datas, offset, count, prev_id, next_id)= mysql_paginate_query(sql, offset, count, prev_id, next_id);
(page, total_record, count)= offset_to_page(offset, count, total_record);
return (datas, page, total_record, count, prev_id, next_id);
mysql_paginate_query(sql, offset, count, prev_id, next_id)
need_offset= is_null(offset);
need_since= is_null(prev_id) || is_null(next_id);
sql_components= sql_parser(sql);
if ( need_offset ) :
sql_components= sql_add_offset(sql_components, offset, count);
endif
if ( need_since ) :
sql_components= sql_add_since(sql_components, prev_id, next_id);
endif
sql= sql_restore(sql_components);
datas= mysql_execute(sql);
(prev_id, next_id)= datas_boundary(sql_components, datas);
ret= (datas);
if ( need_offset ) :
append(ret, offset, count);
endif
if ( need_since ) :
append(ret, prev_id, next_id);
endif
return (ret);</li>
<li>测试点
1) 传统分页
2) 分段分页
3) 原始分页
4) since_id分页
5) 复合型传统分页
6) 复合型分段分页
7) 复合型原始分页</li>
<li>测试数据构建
DROP DATABASE IF EXISTS <code>paginate_test</code>;
CREATE DATABASE IF NOT EXISTS <code>paginate_test</code>;
USE <code>paginate_test</code>;</li>
</ol>

<p>DROP TABLE IF EXISTS <code>feed</code>;
CREATE TABLE IF NOT EXISTS <code>feed</code> (
<code>feed_id</code> INT NOT NULL PRIMARY KEY AUTO_INCREMENT COMMENT &#39;微博ID&#39;, 
<code>ctime</code> INT NOT NULL COMMENT &#39;微博创建时间&#39;, 
<code>content</code> CHAR(20) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;微博内容&#39;, 
<code>transpond_count</code> INT NOT NULL DEFAULT 0 COMMENT &#39;微博转发数&#39;
) COMMENT &#39;微博表&#39;;</p>

<p>DROP TABLE IF EXISTS <code>comment</code>;
CREATE TABLE IF NOT EXISTS <code>comment</code> (
<code>comment_id</code> INT NOT NULL PRIMARY KEY AUTO_INCREMENT COMMENT &#39;评论ID&#39;, 
<code>content</code> CHAR(20) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;评论内容&#39;, 
<code>feed_id</code> INT NOT NUL COMMENT &#39;被评论微博ID&#39;
) COMMENT &#39;评论表&#39;;</p>

<p>DROP TABLE IF EXISTS <code>hot</code>;
CREATE TABLE IF NOT EXISTS <code>hot</code> (
<code>feed_id</code> INT NOT NULL PRIMARY KEY AUTO_INCREMENT COMMENT &#39;微博ID&#39;, 
<code>hot</code> INT NOT NULL DEFAULT 0 COMMENT &#39;微博热度&#39;
) COMMENT &#39;热点微博表&#39;;
9. 测试用例:
1) 搜索最热微博(SELECT f.feed_id, f.content, h.hot FROM feed AS f JOIN hot AS h ON f.feed_id = h.feed_id ORDER BY hhot DESC, f.feed_id DESC)
2) 搜索热评微博(SELECT f.feed_id, f.content, COUNT(c.*) AS count FROM feed AS f JOIN comment AS c ON f.feed_id = c.feed_id GROUP BY c.feed_id ORDER BY count DESC, f.feed_id DESC)
3) 搜索热转微博(SELECT feed_id, content, transpond_count FROM feed ORDER BY transpond_count DESC, feed_id DESC)
4) 上面3种场景均测试7个测试点
10. 文件列表
readme.txt当前您正在阅读的开发文档
page.lib.php分页程序库
test_base.php单元测试基础函数
test_convert.php不同分页之间的转换单元测试
test_parse.phpSQL语句解析测试
test_page.php分页测试</p>

<p>下面是源代码:
page.lib.php</p>

<pre lang="php"><code>&lt;?php
/*
 * 分页程序核心库
 * 1. 各种分页的转换
 * 2. SQL语句解析
 * 3. SQL语句修改
 * 4. SQL语句还原
 * 5. 自动的分页支持
 * author: selfimpr
 * blog: http://blog.csdn.net/lgg201
 * mail: goosman.lei@gmail.com
 */
#分页术语
define(&#39;TERM_DATAS&#39;,                        &#39;datas&#39;);           #分页得到数据
define(&#39;TERM_COUNT&#39;,                        &#39;count&#39;);           #期望的分段记录数
define(&#39;TERM_TOTAL_RECORD&#39;,                 &#39;total_record&#39;);    #总记录数
define(&#39;TERM_OFFSET&#39;,                       &#39;offset&#39;);          #偏移量
define(&#39;TERM_PAGE&#39;,                         &#39;page&#39;);            #页码
define(&#39;TERM_PING&#39;,                         &#39;ping&#39;);            #段号
define(&#39;TERM_PAGE_PING&#39;,                    &#39;page_ping&#39;);       #每页段数
define(&#39;TERM_PREV_ID&#39;,                      &#39;prev_id&#39;);         #范围左标记
define(&#39;TERM_NEXT_ID&#39;,                      &#39;next_id&#39;);         #范围右标记

#sql语法解析错误
define(&#39;E_SQL_SELECT_PARSER&#39;,               &#39;SQL-SELECT语法解析错误: %s&#39;);    #SQL语法解析错误

#SQL语法解析特殊字符
define(&#39;SPACES&#39;,                    &quot; \t\f\r\n&quot;);
define(&#39;QUOTES&#39;,                    &#39;&quot;\&#39;&#39;);
define(&#39;COMMA&#39;,                     &#39;,&#39;);
define(&#39;LBRACKET&#39;,                  &#39;(&#39;);
define(&#39;RBRACKET&#39;,                  &#39;)&#39;);
define(&#39;DOT&#39;,                       &#39;.&#39;);
define(&#39;SPACE&#39;,                     &#39; &#39;);

#SQL语法解析后的组件
define(&#39;CP_SELECT&#39;,                     &#39;_select&#39;);
define(&#39;CP_OPTIONS&#39;,                    &#39;_options&#39;);
define(&#39;CP_FIELDS&#39;,                     &#39;_fields&#39;);
define(&#39;CP_FROM&#39;,                       &#39;_from&#39;);
define(&#39;CP_TABLES&#39;,                     &#39;_tables&#39;);
define(&#39;CPK_TABLES_TABLE&#39;,              &#39;_table&#39;);
define(&#39;CPK_TABLES_ALIAS&#39;,              &#39;_alias&#39;);
define(&#39;CPK_TABLES_CONDITION&#39;,          &#39;_condition&#39;);
define(&#39;CPK_TABLES_SEPARATER&#39;,          &#39;_separater&#39;);
define(&#39;CP_WHERE&#39;,                      &#39;_where&#39;);
define(&#39;CP_CONDITIONS&#39;,                 &#39;_conditions&#39;);
define(&#39;CP_GROUP_BY&#39;,                   &#39;_group_by&#39;);
define(&#39;CP_GROUPS&#39;,                     &#39;_groups&#39;);
define(&#39;CPK_GROUPS_FIELD&#39;,              &#39;_field&#39;);
define(&#39;CPK_GROUPS_ORDER&#39;,              &#39;_order&#39;);
define(&#39;CP_HAVING&#39;,                     &#39;_having&#39;);
define(&#39;CP_FILTERS&#39;,                    &#39;_filters&#39;);
define(&#39;CP_ORDER_BY&#39;,                   &#39;_order_by&#39;);
define(&#39;CP_ORDERS&#39;,                     &#39;_orders&#39;);
define(&#39;CPK_ORDERS_FIELD&#39;,              &#39;_field&#39;);
define(&#39;CPK_ORDERS_ORDER&#39;,              &#39;_order&#39;);
define(&#39;CP_LIMIT&#39;,                      &#39;_limit&#39;);
define(&#39;CP_OFFSET&#39;,                     &#39;_offset&#39;);
define(&#39;CP_COUNT&#39;,                      &#39;_count&#39;);

#SQL语法中的关键字
define(&#39;KW_COUNT&#39;,                      &#39;COUNT&#39;);
define(&#39;KW_SELECT&#39;,                     &#39;SELECT&#39;);
define(&#39;KW_ALL&#39;,                        &#39;ALL&#39;);
define(&#39;KW_DISTINCT&#39;,                   &#39;DISTINCT&#39;);
define(&#39;KW_DISTINCTROW&#39;,                &#39;DISTINCTROW&#39;);
define(&#39;KW_HIGH_PRIORITY&#39;,              &#39;HIGH_PRIORITY&#39;);
define(&#39;KW_STRAIGHT_JOIN&#39;,              &#39;STRAIGHT_JOIN&#39;);
define(&#39;KW_SQL_SMALL_RESULT&#39;,           &#39;SQL_SMALL_RESULT&#39;);
define(&#39;KW_SQL_BIG_RESULT&#39;,             &#39;SQL_BIG_RESULT&#39;);
define(&#39;KW_SQL_BUFFER_RESULT&#39;,          &#39;SQL_BUFFER_RESULT&#39;);
define(&#39;KW_SQL_CACHE&#39;,                  &#39;SQL_CACHE&#39;);
define(&#39;KW_SQL_NO_CACHE&#39;,               &#39;SQL_NO_CACHE&#39;);
define(&#39;KW_SQL_CALC_FOUND_ROWS&#39;,        &#39;SQL_CALC_FOUND_ROWS&#39;);
define(&#39;KW_FROM&#39;,                       &#39;FROM&#39;);
define(&#39;KW_WHERE&#39;,                      &#39;WHERE&#39;);
define(&#39;KW_JOIN&#39;,                       &#39;JOIN&#39;);
define(&#39;KW_LEFT&#39;,                       &#39;LEFT&#39;);
define(&#39;KW_RIGHT&#39;,                      &#39;RIGHT&#39;);
define(&#39;KW_INNER&#39;,                      &#39;INNER&#39;);
define(&#39;KW_OUTER&#39;,                      &#39;OUTER&#39;);
define(&#39;KW_CROSS&#39;,                      &#39;CROSS&#39;);
define(&#39;KW_AS&#39;,                         &#39;AS&#39;);
define(&#39;KW_ON&#39;,                         &#39;ON&#39;);
define(&#39;KW_GROUP&#39;,                  &#39;GROUP&#39;);
define(&#39;KW_ORDER&#39;,                  &#39;ORDER&#39;);
define(&#39;KW_BY&#39;,                     &#39;BY&#39;);
define(&#39;KW_GROUP_BY&#39;,               KW_GROUP . SPACE . KW_BY);
define(&#39;KW_HAVING&#39;,                 &#39;HAVING&#39;);
define(&#39;KW_ORDER_BY&#39;,               KW_ORDER . SPACE . KW_BY);
define(&#39;KW_ASC&#39;,                    &#39;ASC&#39;);
define(&#39;KW_DESC&#39;,                   &#39;DESC&#39;);
define(&#39;KW_LIMIT&#39;,                  &#39;LIMIT&#39;);
define(&#39;KW_AND&#39;,                    &#39;AND&#39;);
define(&#39;KW_OR&#39;,                     &#39;OR&#39;);
define(&#39;KWS_EQ&#39;,                    &#39;=&#39;);
define(&#39;KWS_LT&#39;,                    &#39;&lt;&#39;);
define(&#39;KWS_GT&#39;,                    &#39;&gt;&#39;);
define(&#39;KWS_LE&#39;,                    &#39;&lt;=&#39;);
define(&#39;KWS_GE&#39;,                    &#39;&gt;=&#39;);

define(&#39;ORDER_ALIAS_PREFIX&#39;,        &#39;__o_&#39;);
define(&#39;SINCE_ID_SEPARATER_0&#39;,      &#39;|&#39;);
define(&#39;SINCE_ID_SEPARATER_1&#39;,      &#39;:&#39;);
define(&#39;DIRECT_PREV&#39;,               &#39;PREV&#39;);
define(&#39;DIRECT_NEXT&#39;,               &#39;NEXT&#39;);
define(&#39;COUNT_DEFAULT_ALIAS&#39;,       &#39;__c&#39;);

#当前解析器需要处理的SELECT选项
define(&#39;ENABLE_OPTIONS&#39;,                &#39;_enable_options&#39;);
$GLOBALS[ENABLE_OPTIONS]    = array(
    KW_ALL, KW_DISTINCT, KW_DISTINCTROW, 
    KW_HIGH_PRIORITY, KW_STRAIGHT_JOIN, KW_SQL_SMALL_RESULT, 
    KW_SQL_BIG_RESULT, KW_SQL_BUFFER_RESULT, KW_SQL_CACHE, 
    KW_SQL_NO_CACHE, KW_SQL_CALC_FOUND_ROWS, 
);

function p_datas($info) {
    return $info[TERM_DATAS];
}
#读取每段记录数
function p_count($info) {
    return intval($info[TERM_COUNT]);
}
#读取总记录数
function p_total_record($info) {
    return intval($info[TERM_TOTAL_RECORD]);
}
#读取偏移量
function p_offset($info) {
    return intval($info[TERM_OFFSET]);
}
#读取页码
function p_page($info) {
    return intval($info[TERM_PAGE]);
}
#读取分段号
function p_ping($info) {
    return intval($info[TERM_PING]);
}
#读取每页分段数
function p_page_ping($info) {
    return intval($info[TERM_PAGE_PING]);
}
#读取范围左标识
function p_prev_id($info) {
    return strval($info[TERM_PREV_ID]);
}
#读取范围右标识
function p_next_id($info) {
    return strval($info[TERM_NEXT_ID]);
}

#分段分页到偏移量转换
function ping_to_offset($page, $ping, $page_ping, $count, $total_record) {
    $ping       = min($page_ping, max(1, $ping));
    $total_ping = ceil($total_record / $count);
    $total_page = ceil($total_ping / $page_ping);
    $page       = min($total_page, max(1, $page));
    $real_ping  = ($page - 1) * $page_ping + $ping;
    $real_ping  = min($total_ping, max(1, $real_ping));
    $offset     = ($real_ping - 1) * $count;
    return array(
        TERM_OFFSET =&gt; intval($offset), 
        TERM_COUNT  =&gt; intval($count), 
    );
}
#偏移量到分段分页转换
function offset_to_ping($offset, $page_ping, $count) {
    $real_ping  = ($offset / $count) + 1;
    $ping       = ($real_ping - 1) % $page_ping + 1;
    $page       = ($real_ping - $ping) / $page_ping + 1;
    return array(
        TERM_PAGE           =&gt; intval($page), 
        TERM_PING           =&gt; intval($ping), 
        TERM_PAGE_PING      =&gt; intval($page_ping), 
        TERM_COUNT          =&gt; intval($count), 
    );
}
#传统分页到偏移量转换
function page_to_offset($page, $count, $total_record) {
    $total_page = ceil($total_record / $count);
    $page       = min($total_page, max(1, $page));
    $offset     = ($page - 1) * $count;
    return array(
        TERM_OFFSET =&gt; intval($offset), 
        TERM_COUNT  =&gt; intval($count), 
    );
}
#偏移量到传统分页转换
function offset_to_page($offset, $count) {
    $page   = floor($offset / $count) + 1;
    return array(
        TERM_PAGE   =&gt; intval($page), 
        TERM_COUNT  =&gt; intval($count), 
    );
}


#------------------------------------------------SQL语法解析器
/* 解析器要处理的SELECT语法
SELECT
    [ALL | DISTINCT | DISTINCTROW ]
      [HIGH_PRIORITY]
      [STRAIGHT_JOIN]
      [SQL_SMALL_RESULT] [SQL_BIG_RESULT] [SQL_BUFFER_RESULT]
      [SQL_CACHE | SQL_NO_CACHE] [SQL_CALC_FOUND_ROWS]
    select_expr [, select_expr ...]
    [FROM table_references
    [WHERE where_condition]
    [GROUP BY {col_name | expr | position}
      [ASC | DESC], ... [WITH ROLLUP]]
    [HAVING where_condition]
    [ORDER BY {col_name | expr | position}
      [ASC | DESC], ...]
    [LIMIT {[offset,] row_count | row_count OFFSET offset}]
*/
#符合mysql语法规范的SELECT语句
function sql_parser($sql) {
    $tokens     = sql_tokens($sql);
    $components = sql_analysis($tokens);
    return $components;
}
#sql_parser的逆向函数
/* sql_components的结构
array(
    CP_SELECT       =&gt; KW_SELECT,                                   #SELECT关键字
    CP_OPTIONS      =&gt; $GLOBALS[ENABLE_OPTIONS],                    #SELECT选项
    CP_FIELDS       =&gt; array(                                       #查询字段
        array(&#39;field_0_comp_0&#39;, &#39;field_0_comp_1&#39;, ...),             #字段0的构成
        array(&#39;field_1_comp_0&#39;, &#39;field_2_comp_1&#39;, ...),             #字段1的构成
        ...
    ), 
    CP_FROM         =&gt; KW_FROM,                                     #FROM关键字
    CP_TABLES       =&gt; array(                                       #目标表
        array(
            CPK_TABLES_TABLE        =&gt; array(&#39;table_0_comp_0&#39;, &#39;table_0_comp_1&#39;, ...),      #数据表描述
            CPK_TABLES_ALIAS        =&gt; &#39;alias&#39;,                                             #别名
            CPK_TABLES_CONDITION    =&gt; array(&#39;cond_0_comp_0&#39;, &#39;cond_0_comp_1&#39;, ...),        #条件
        ), 
        array(
            CPK_TABLES_SEPARATER    =&gt; array(KW_LEFT, KW_JOIN),                             #表0和表1的连接符(KW_LEFT, KW_RIGHT, KW_INNER, KW_CROSS, KW_OUTER, KW_JOIN, COMMA)
            CPK_TABLES_TABLE        =&gt; array(&#39;table_1_comp_0&#39;, &#39;table_1_comp_1&#39;, ...),      #数据表描述
            CPK_TABLES_ALIAS        =&gt; &#39;alias&#39;,                                             #别名
            CPK_TABLES_CONDITION    =&gt; array(&#39;cond_1_comp_0&#39;, &#39;cond_1_comp_1&#39;, ...),        #条件
        ), 
    ), 
    CP_WHERE        =&gt; KW_WHERE,                                    #WHERE关键字
    CP_CONDITIONS   =&gt; array(                                       #查询条件(WHERE)
        array(&#39;cond_comp_0&#39;, &#39;cond_comp_1&#39;, ...),                   #条件构件
    ), 
    CP_GROUP_BY     =&gt; KW_GROUP_BY                                  #GROUP BY关键字
    CP_GROUPS       =&gt; array(                                                               #分组项
        array(
            CPK_GROUPS_FIELD =&gt; array(&#39;field_0_comp_0&#39;, &#39;field_0_comp_1&#39;, ...),             #分组项0的字段构件
            CPK_GROUPS_ORDER =&gt; KW_ASC,                                                     #分组项0的排序规则(KW_ASC, KW_DESC)
        ), 
        array(
            CPK_GROUPS_FIELD =&gt; array(&#39;field_1_comp_0&#39;, &#39;field_0_comp_1&#39;, ...),             #分组项1的字段构件
            CPK_GROUPS_ORDER =&gt; KW_DESC,                                                    #分组项1的排序规则(KW_ASC, KW_DESC)
        ), 
    ), 
    CP_HAVING       =&gt; KW_HAVING,                                   #HAVING关键字
    CP_FILTERS      =&gt; array(                                       #过滤条件(HAVING)
        array(&#39;cond_comp_0&#39;, &#39;cond_comp_1&#39;, ...),                   #条件构件
    ), 
    CP_ORDER_BY     =&gt; KW_ORDER_BY,                                 #ORDER BY关键字
    CP_ORDERS       =&gt; array(                                                               #排序项
        array(
            CPK_ORDERS_FIELD =&gt; array(&#39;field_0_comp_0&#39;, &#39;field_0_comp_1&#39;, ...),             #排序项0的字段构件
            CPK_ORDERS_ORDER =&gt; KW_ASC,                                                     #排序项0的排序规则(KW_ASC, KW_DESC)
        ), 
        array(
            CPK_ORDERS_FIELD =&gt; array(&#39;field_1_comp_0&#39;, &#39;field_0_comp_1&#39;, ...),             #排序项1的字段构件
            CPK_ORDERS_ORDER =&gt; KW_DESC,                                                    #排序项1的排序规则(KW_ASC, KW_DESC)
        ), 
    ), 
    CP_LIMIT        =&gt; KW_LIMIT,                                    #LIMIT关键字
    CP_OFFSET       =&gt; 0,                                           #偏移量
    CP_COUNT        =&gt; 10,                                          #最大记录数
);
TODO 实现还原
 */
function sql_restore($sc) {
    $r  = array();
    sr_restore_select($sc, $r);
    sr_restore_options($sc, $r); 
    sr_restore_fields($sc, $r); 
    sr_restore_tables($sc, $r); 
    sr_restore_conditions($sc, $r); 
    sr_restore_groups($sc, $r); 
    sr_restore_filters($sc, $r); 
    sr_restore_orders($sc, $r); 
    sr_restore_offset_count($sc, $r);
    return implode_exclude_bracket(SPACE, $r);
}
#将SQL语句转换为计数SQL(不支持外连接)
function sql_to_count($sql, $alias = COUNT_DEFAULT_ALIAS) {
    $sc = sql_parser($sql);
    $sc = sc_to_count($sc, $alias);
    return sql_restore($sc);
}
#SQL语句增加since_id
function sql_add_since($sql, $prev_id, $next_id, &amp;$need_reverse) {
    $sc = sql_parser($sql);
    $sc = sc_add_since($sc, $prev_id, $next_id, $need_reverse);
    return sql_restore($sc);
}
#为SQL语句设置偏移量
function sql_add_offset($sql, $offset, $count) {
    $sc = sql_parser($sql);
    $sc = sc_add_offset($sql, $offset, $count);
    return sql_restore($sc);
}
#对外的单一接口提供
/* 
    1) 传统分页
    2) 分段分页
    3) 原始分页
    4) since_id分页
    5) 复合型传统分页
    6) 复合型分段分页
    7) 复合型原始分页
 */
function mysql_paginate_query($conn, $sql, $count, $offset = NULL, $prev_id = NULL, $next_id = NULL) {
    #修正偏移量
    $offset = correct_offset($offset);
    $sc     = sql_parser($sql);

    #增加偏移量
    sc_add_offset($sc, $offset, $count);

    #增加since条件
    sc_add_since($sc, $prev_id, $next_id, $need_reverse);

    #结构化SQL到SQL语句
    $sql    = sql_restore($sc);
    #执行查询
    $datas  = mysql_geta_all($conn, $sql);
    if ( $need_reverse )
        $datas  = array_reverse($datas);
    #获取新的数据边界
    if ( $prev_id || $next_id )
        sc_datas_boundary($sc, $datas, $prev_id, $next_id);

    return array(
        TERM_DATAS      =&gt; $datas, 
        TERM_OFFSET     =&gt; $offset, 
        TERM_COUNT      =&gt; $count, 
        TERM_PREV_ID    =&gt; $prev_id, 
        TERM_NEXT_ID    =&gt; $next_id, 
    );
}
#获取Top N数据
function mysql_paginate_top($conn, $sql, $count) {
    #获取总记录数
    $total_record   = mysql_get_total_record($conn, $sql);
    #读取数据
    $data_info  = mysql_paginate_query($conn, $sql, 
                $count, NULL, 
                NULL, NULL);
    return array(
        TERM_DATAS          =&gt; p_datas($data_info), 
        TERM_COUNT          =&gt; p_count($data_info), 
        TERM_TOTAL_RECORD   =&gt; $total_record, 
    );
}
#传统方式结合since_id分页
#(TODO 分段分页/传统分页/原始分页与since_id分页联合使用时, 记录数是since_id条件附加之前的记录数, 因此会导致页码数据错乱, 目前不对此进行处理)
function mysql_paginate_tradition_since_id($conn, $sql, $page, 
        $count, $prev_id = NULL, $next_id = NULL, $total_record = NULL) {
    #修正总记录数
    mysql_correct_total_record($conn, $sql, $total_record);
    #分页信息转换为偏移量
    $offset_info    = page_to_offset($page, $count, $total_record);
    #读取数据
    $data_info  = mysql_paginate_query($conn, $sql, 
                p_count($offset_info), p_offset($offset_info), 
                $prev_id, $next_id);
    #修正为页码信息
    $page_info      = offset_to_page(p_offset($data_info), p_count($data_info));
    return array(
        TERM_DATAS          =&gt; p_datas($data_info), 
        TERM_PAGE           =&gt; p_page($page_info), 
        TERM_TOTAL_RECORD   =&gt; $total_record, 
        TERM_COUNT          =&gt; p_count($page_info), 
        TERM_PREV_ID        =&gt; p_prev_id($data_info), 
        TERM_NEXT_ID        =&gt; p_next_id($data_info), 
    );
}
#单纯的传统分页
function mysql_paginate_tradition($conn, $sql, $page, $count, $total_record = NULL) {
    $info   = mysql_paginate_tradition_since_id($conn, $sql, $page, $count, NULL, NULL, $total_record);
    unset($info[TERM_PREV_ID]);
    unset($info[TERM_NEXT_ID]);
    return $info;
}
#分段分页结合since_id分页
#(TODO 分段分页/传统分页/原始分页与since_id分页联合使用时, 记录数是since_id条件附加之前的记录数, 因此会导致页码数据错乱, 目前不对此进行处理)
function mysql_paginate_ping_since_id($conn, $sql, $page, $ping, 
        $page_ping, $count, $prev_id = NULL, $next_id = NULL, $total_record = NULL) {
    #修正总记录数
    mysql_correct_total_record($conn, $sql, $total_record);
    #分段信息转换为offset
    $offset_info    = ping_to_offset($page, $ping, $page_ping, $count, $total_record);
    #读取数据
    $data_info      = mysql_paginate_query($conn, $sql, 
                    p_count($offset_info), p_offset($offset_info), 
                    $prev_id, $next_id);
    #修正为分段信息
    $ping_info      = offset_to_ping(p_offset($data_info), 
                    $page_ping, p_count($data_info));
    return array(
        TERM_DATAS          =&gt; p_datas($data_info), 
        TERM_PAGE           =&gt; p_page($ping_info), 
        TERM_PING           =&gt; p_ping($ping_info), 
        TERM_PAGE_PING      =&gt; p_page_ping($ping_info), 
        TERM_COUNT          =&gt; p_count($ping_info), 
        TERM_TOTAL_RECORD   =&gt; $total_record, 
        TERM_PREV_ID        =&gt; p_prev_id($data_info), 
        TERM_NEXT_ID        =&gt; p_next_id($data_info), 
    );
}
#单纯的分段分页
function mysql_paginate_ping($conn, $sql, $page, $ping, $page_ping, $count, $total_record = NULL) {
    $info   = mysql_paginate_ping_since_id($conn, $sql, $page, $ping, 
            $page_ping, $count, NULL, NULL, $total_record);
    unset($info[TERM_PREV_ID]);
    unset($info[TERM_NEXT_ID]);
    return $info;
}
#原始分页结合since_id分页
#(TODO 分段分页/传统分页/原始分页与since_id分页联合使用时, 记录数是since_id条件附加之前的记录数, 因此会导致页码数据错乱, 目前不对此进行处理)
function mysql_paginate_raw_since_id($conn, $sql, $offset, $count, 
        $prev_id = NULL, $next_id = NULL, $total_record = NULL) {
    #修正总记录数
    mysql_correct_total_record($conn, $sql, $total_record);
    $offset         = min($total_record, max(0, $offset));
    #读取数据
    $data_info      = mysql_paginate_query($conn, $sql, 
                    $count, $offset, $prev_id, $next_id);
    return array(
        TERM_DATAS          =&gt; p_datas($data_info), 
        TERM_OFFSET         =&gt; p_offset($data_info), 
        TERM_COUNT          =&gt; p_count($data_info), 
        TERM_TOTAL_RECORD   =&gt; $total_record, 
        TERM_PREV_ID        =&gt; p_prev_id($data_info), 
        TERM_NEXT_ID        =&gt; p_next_id($data_info), 
    );
}
#单纯的原始分页
function mysql_paginate_raw($conn, $sql, $offset, $count, $total_record = NULL) {
    $info   = mysql_paginate_raw_since_id($conn, $sql, $offset, $count, NULL, NULL, $total_record);
    unset($info[TERM_PREV_ID]);
    unset($info[TERM_NEXT_ID]);
    return $info;
}
#单纯的since_id分页
function mysql_paginate_since_id($conn, $sql, $count, $prev_id = NULL, $next_id = NULL) {
    #获取总记录数
    $total_record   = mysql_get_total_record($conn, $sql);
    #读取数据
    $data_info  = mysql_paginate_query($conn, $sql, $count, NULL,
                is_null($prev_id) ? TRUE : $prev_id,
                is_null($next_id) ? TRUE : $next_id);
    return array(
        TERM_DATAS          =&gt; p_datas($data_info), 
        TERM_PREV_ID        =&gt; p_prev_id($data_info), 
        TERM_NEXT_ID        =&gt; p_next_id($data_info), 
        TERM_COUNT          =&gt; p_count($data_info), 
        TERM_TOTAL_RECORD   =&gt; $total_record, 
    );
}
#获取总记录数
function mysql_get_total_record($conn, $sql) {
    $sql    = sql_to_count($sql, COUNT_DEFAULT_ALIAS);
    $row    = mysql_geta($conn, $sql);
    $total_record   = $row[COUNT_DEFAULT_ALIAS];
    return $total_record;
}
#修正总记录数
function mysql_correct_total_record($conn, $sql, &amp;$total_record = NULL) {
    if ( !is_numeric($total_record) ) 
        $total_record   = intval(mysql_get_total_record($conn, $sql));
    $total_record   = intval($total_record);
}



#-------------------------------------------------------------------------以下部分是基础函数, 非外部接口
#----------------------------------------SQL语句解析基础函数
#将sql字符串处理为tokens
/*
 * 1. 忽略空白元素
 * 2. 将逗号/左括号/右括号作为词法单元处理
 * 3. 对字符串字面量特殊处理(防止转义等带来的影响)
 * 语法描述
SELECT      ::= UNIT SEPARATER UNIT [SEPARATER UNIT [...]]
UNIT        ::= WORD | LITERAL
SEPARATER   ::= COMMA | SPACES | LBRACKET | RBRACKET
LITERAL     ::= LQUOTE WORD RQUOTE
WORD        ::= CHARACTER [CHARACTER [...]]
LQUOTE      ::= &quot;&#39;&quot; | &quot;\&quot;&quot;
RQUOTE      ::= &quot;&#39;&quot; | &quot;\&quot;&quot;
CHARACTER   ::= #非特殊含义字符集
LBRACKET    ::= &quot;(&quot;
RBRACKET    ::= &quot;)&quot;
COMMA       ::= &quot;,&quot;
SPACES      ::= &quot; &quot; | &quot;\t&quot; | &quot;\f&quot; | &quot;\r&quot; | &quot;\n&quot;
 */
function sql_tokens($s) {
    $r  = array();
    $l  = strlen($s);
    while ( $l &gt; 0 ) {
        if ( sp_is_quote($s) ) {
            sp_read_string($s, $l, $r);
        } else if ( sp_is_space($s) ) {
            sp_read_spaces($s, $l);
        } else if ( sp_is_comma($s) ) {
            sp_read_comma($s, $l, $r);
        } else if ( sp_is_lbracket($s) ) {
            sp_read_lbracket($s, $l, $r);
        } else if ( sp_is_rbracket($s) ) {
            sp_read_rbracket($s, $l, $r);
        } else {
            sp_read_word($s, $l, $r);
        }
    }
    return $r;
}
#对解析得到的词法单元进行语法分析
function sql_analysis($t) {
    $r  = array();
    $i  = 0;
    $l  = count($t);
    #读取SELECT关键字
    spa_read_select($t, $i, $l, $r);
    #读取SELECT选项
    spa_read_options($t, $i, $l, $r);
    #读取查询的目标字段
    spa_read_fields($t, $i, $l, $r);
    if ( spa_is_from($t, $i) ) {
        #读取FROM关键字
        spa_read_from($t, $i, $l, $r);
        #读取查询的目标表
        spa_read_tables($t, $i, $l, $r);
    }
    if ( spa_is_where($t, $i) ) {
        #读取WHERE关键字
        spa_read_where($t, $i, $l, $r);
        #读取查询条件
        spa_read_conditions($t, $i, $l, $r);
    }
    if ( spa_is_group_by($t, $i) ) {
        #读取GROUP BY关键字
        spa_read_group_by($t, $i, $l, $r);
        #读取分组信息
        spa_read_groups($t, $i, $l, $r);
    }
    if ( spa_is_having($t, $i) ) {
        #读取HAVING关键字
        spa_read_having($t, $i, $l, $r);
        #读取结果集过滤条件
        spa_read_filters($t, $i, $l, $r);
    }
    if ( spa_is_order_by($t, $i) ) {
        #读取ORDER BY关键字
        spa_read_order_by($t, $i, $l, $r);
        #读取排序信息
        spa_read_orders($t, $i, $l, $r);
    }
    if ( spa_is_limit($t, $i) ) {
        #读取LIMIT关键字
        spa_read_limit($t, $i, $l, $r);
        #读取偏移量和最大记录数
        spa_read_offset_count($t, $i, $l, $r);
    }
    return $r;
}
#----------------------------------错误处理
#sql语法解析错误处理
function sql_parser_error() {
    $msgs   = func_get_args();
    trigger_error(sprintf(E_SQL_SELECT_PARSER, implode(&quot;\t&quot;, $msgs)), E_USER_ERROR);
}
#------------------------------------词法分析基础函数
#词法分析: 检查是否空白字符
function sp_is_space($s) {
    return strpos(SPACES, $s[0]) !== FALSE;
}
#词法分析: 检查是否引号
function sp_is_quote($s) {
    return strpos(QUOTES, $s[0]) !== FALSE;
}
#词法分析: 检查是否逗号
function sp_is_comma($s) {
    return $s[0] === COMMA;
}
#词法分析: 检查是否左括号
function sp_is_lbracket($s) {
    return $s[0] === LBRACKET;
}
#词法分析: 检查是否右括号
function sp_is_rbracket($s) {
    return $s[0] === RBRACKET;
}
#词法分析: 检查是否单词字符(认为所有非上面列出的5种特殊字符, 均为单词字符)
function sp_is_wordchar($s) {
    return !sp_is_quote($s) &amp;&amp; !sp_is_space($s) &amp;&amp; !sp_is_comma($s) &amp;&amp; !sp_is_lbracket($s) &amp;&amp; !sp_is_rbracket($s);
}
#词法分析: 读取词法单元的基础函数
function sp_read_base($f, &amp;$s, &amp;$l, &amp;$r = NULL, $single = FALSE) {
    $i  = -1;
    while ( ++ $i &lt; $l ) 
        #检查是否符合词法单元条件
        if ( !$f($s[$i]) || ($single &amp;&amp; $i &gt; 0) )
            break;
    if ( !is_null($r) )
        $r[]    = substr($s, 0, $i);
    $s  = substr($s, $i);
    $l  -= $i;
}
#词法分析: 读取空白单元
function sp_read_spaces(&amp;$s, &amp;$l, &amp;$r = NULL) {
    sp_read_base(&#39;sp_is_space&#39;, $s, $l, $r);
}
#词法分析: 读取逗号单元
function sp_read_comma(&amp;$s, &amp;$l, &amp;$r = NULL) {
    sp_read_base(&#39;sp_is_comma&#39;, $s, $l, $r, TRUE);
}
#词法分析: 读取单词单元
function sp_read_word(&amp;$s, &amp;$l, &amp;$r = NULL) {
    sp_read_base(&#39;sp_is_wordchar&#39;, $s, $l, $r);
}
#词法分析: 读取左括号单元
function sp_read_lbracket(&amp;$s, &amp;$l, &amp;$r = NULL) {
    sp_read_base(&#39;sp_is_lbracket&#39;, $s, $l, $r, TRUE);
}
#词法分析: 读取右括号单元
function sp_read_rbracket(&amp;$s, &amp;$l, &amp;$r = NULL) {
    sp_read_base(&#39;sp_is_rbracket&#39;, $s, $l, $r, TRUE);
}
#词法分析: 读取字符串字面量单元
function sp_read_string(&amp;$s, &amp;$l, &amp;$r = NULL) {
    if ( !sp_is_quote($s) ) 
        sql_parser_error(__FILE__, __LINE__, __FUNCTION__);
    $q  = $s[0];
    $i  = 1;
    $e  = FALSE;
    while ( $i &lt; $l ) {
        #读取字符并下移指针
        $c  = $s[$i ++];
        #转义状态直接将设置为非转义状态
        if ( $e ) $e = FALSE;
        #终止引号跳出处理
        else if ( $c === $q ) break;
        #转义字符设置转义状态
        else if ( $c === &#39;\\&#39; ) $e = TRUE;
    }
    if ( $i &gt; $l || $e ) 
        sql_parser_error(__FILE__, __LINE__, __FUNCTION__);
    if ( !is_null($r) )
        $r[]    = substr($s, 0, $i);
    $s  = substr($s, $i);
    $l  -= $i;
}

#--------------------------------------------语法分析基础函数-简单语法单元检查
#语法分析: 检查是否逗号
function spa_is_comma($t, $i, &amp;$n = NULL) {
    $n  = 1;
    return sp_is_comma($t[$i]);
}
#语法分析: 检查是否左括号
function spa_is_lbracket($t, $i, &amp;$n = NULL) {
    $n  = 1;
    return sp_is_lbracket($t[$i]);
}
#语法分析: 检查是否右括号
function spa_is_rbracket($t, $i, &amp;$n = NULL) {
    $n  = 1;
    return sp_is_rbracket($t[$i]);
}
#语法分析: 检查是否句点
function spa_is_dot($t, $i, &amp;$n = NULL) {
    $n  = 1;
    return strtoupper($t[$i]) === DOT;
}
#语法分析: 检查是否SELECT
function spa_is_select($t, $i, &amp;$n = NULL) {
    $n  = 1;
    return strtoupper($t[$i]) === KW_SELECT;
}
#语法分析: 检查是否SELECT选项
function spa_is_option($t, $i, &amp;$n = NULL) {
    $n  = 1;
    return in_array(strtoupper($t[$i]), $GLOBALS[ENABLE_OPTIONS]);
}
#语法分析: 检查是否FROM
function spa_is_from($t, $i, &amp;$n = NULL) {
    $n  = 1;
    return strtoupper($t[$i]) === KW_FROM;
}
#语法分析: 检查是否WHERE
function spa_is_where($t, $i, &amp;$n = NULL) {
    $n  = 1;
    return strtoupper($t[$i]) === KW_WHERE;
}
#语法分析: 检查是否JOIN
/* 实现语法:
join_table:
      table_reference [INNER | CROSS] JOIN table_factor [join_condition]
    | table_reference {LEFT|RIGHT} [OUTER] JOIN table_reference join_condition
 */
function spa_is_join($t, $i, &amp;$n = NULL) {
    $t_i0   = strtoupper($t[$i]);
    $t_i1   = strtoupper($t[$i + 1]);
    $t_i2   = strtoupper($t[$i + 2]);
    if ( $t_i0 !== KW_JOIN &amp;&amp; $t_i1 !== KW_JOIN &amp;&amp; $t_i2 !== KW_JOIN )
        return FALSE;
    if ( $t_i0 === KW_JOIN ) 
        $n  = 1;
    else if ( $t_i1 === KW_JOIN ) {
        if ( $t_i0 !== KW_INNER &amp;&amp; $t_i0 !== KW_CROSS &amp;&amp; $t_i0 !== KW_LEFT &amp;&amp; $t_i0 !== KW_RIGHT )
            return FALSE;
        $n  = 2;
    } else if ( $t_i2 === KW_JOIN ) {
        if ( $t_i0 !== KW_LEFT &amp;&amp; $t_i0 !== KW_RIGHT || $t_i1 !== OUTER ) 
            return FALSE;
        $n  = 3;
    }
    return TRUE;
}
#语法分析: 检查是否AS
function spa_is_as($t, $i, &amp;$n = NULL) {
    $n  = 1;
    return strtoupper($t[$i]) === KW_AS;
}
#语法分析: 检查是否ON
function spa_is_on($t, $i, &amp;$n = NULL) {
    $n  = 1;
    return strtoupper($t[$i]) === KW_ON;
}
#语法分析: 检查是否GROUP BY
function spa_is_group_by($t, $i, &amp;$n = NULL) {
    $n  = 2;
    return strtoupper($t[$i]) === KW_GROUP &amp;&amp; strtoupper($t[$i + 1]) === KW_BY;
}
#语法分析: 检查是否HAVING
function spa_is_having($t, $i, &amp;$n = NULL) {
    $n  = 1;
    return strtoupper($t[$i]) === KW_HAVING;
}
#语法分析: 检查是否ORDER BY
function spa_is_order_by($t, $i, &amp;$n = NULL) {
    $n  = 2;
    return strtoupper($t[$i]) === KW_ORDER &amp;&amp; strtoupper($t[$i + 1]) === KW_BY;
}
#语法分析: 检查是否ASC
function spa_is_asc($t, $i, &amp;$n = NULL) {
    $n  = 1;
    return strtoupper($t[$i]) === KW_ASC;
}
#语法分析: 检查是否DESC
function spa_is_desc($t, $i, &amp;$n = NULL) {
    $n  = 1;
    return strtoupper($t[$i]) === KW_DESC;
}
#语法分析: 检查是否LIMIT
function spa_is_limit($t, $i, &amp;$n = NULL) {
    $n  = 1;
    return strtoupper($t[$i]) === KW_LIMIT;
}
#---------------------------------------语法分析-语法边界检查
#CP_FIELDS语法单元中单条field自身结束而非整个语法单元结束的检查
function spa_end_field_self($t, $i, $l) {
    return spa_is_comma($t, $i) || $i &gt;= $l;
}
#CP_FIELDS语法单元结束标记检查
function spa_end_fields($t, $i, $l) {
    return spa_is_from($t, $i) || spa_is_where($t, $i) || spa_is_group_by($t, $i) || spa_is_having($t, $i)
        || spa_is_order_by($t, $i) || spa_is_limit($t, $i) || $i &gt;= $l;
}
#CP_FIELDS语法单元中的单条field结束标记检查
function spa_end_field($t, $i, $l) {
    return spa_end_field_self($t, $i, $l) || spa_end_fields($t, $i, $l);
}
#CP_TABLES语法单元中单表自身结束而非整个语法单元结束的检查
function spa_end_table_self($t, $i, $l) {
    return spa_is_comma($t, $i) || spa_is_join($t, $i) || $i &gt;= $l;
}
#CP_TABLES语法单元结束标记检查
function spa_end_tables($t, $i, $l) {
    return spa_is_where($t, $i) || spa_is_group_by($t, $i) || spa_is_having($t, $i)
        || spa_is_order_by($t, $i) || spa_is_limit($t, $i) || $i &gt;= $l;
}
#CP_TABLES语法单元中的单表结束标记检查
function spa_end_table($t, $i, $l) {
    return spa_end_table_self($t, $i, $l) || spa_end_tables($t, $i, $l);
}
#CP_CONDITIONS语法单元中单条条件自身结束而非整个语法单元结束的检查
function spa_end_condition_self($t, $i, $l) {
#TODO 暂时不对where条件做详细处理
    return $i &gt;= $l;
}
#CP_CONDITIONS语法单元的结束标记检查
function spa_end_conditions($t, $i, $l) {
    return spa_is_group_by($t, $i)  || spa_is_having($t, $i)|| spa_is_order_by($t, $i)
        || spa_is_limit($t, $i) || $i &gt;= $l;
}
#CP_CONDITIONS语法单元中的单条条件结束标记检查
function spa_end_condition($t, $i, $l) {
    return spa_end_condition_self($t, $i, $l) || spa_end_conditions($t, $i, $l);
}
#CP_GROUPS语法单元中单个分组标记自身结束而非整个语法单元结束的检查
function spa_end_group_self($t, $i, $l) {
    return spa_is_comma($t, $i) || $i &gt;= $l;
}
#CP_GROUPS语法单元中的结束标记检查
function spa_end_groups($t, $i, $l) {
    return spa_is_having($t, $i) || spa_is_order_by($t, $i) || spa_is_limit($t, $i) || $i &gt;= $l;
}
#CP_GROUPS语法单元中的单个分组标记结束标记检查
function spa_end_group($t, $i, $l) {
    return spa_end_group_self($t, $i, $l) || spa_end_groups($t, $i, $l);
}
#CP_FILTERS语法单元中单条条件自身结束而非整个语法单元结束的检查
function spa_end_filter_self($t, $i, $l) {
#TODO 暂时不对having条件做详细处理
    return $i &gt;= $l;
}
#CP_FILTERS语法单元中的结束标记检查
function spa_end_filters($t, $i, $l) {
    return spa_is_order_by($t, $i) || spa_is_limit($t, $i) || $i &gt;= $l;
}
#CP_FILTERS语法单元中的单条条件结束标记检查
function spa_end_filter($t, $i, $l) {
    return spa_end_filter_self($t, $i, $l) || spa_end_filters($t, $i, $l);
}
#CP_ORDERS语法单元中单条排序规则自身结束而非整个语法单元结束的检查
function spa_end_order_self($t, $i, $l) {
    return spa_is_comma($t, $i) || $i &gt;= $l;
}
#CP_ORDERS语法单元中的结束标记检查
function spa_end_orders($t, $i, $l) {
    return spa_is_limit($t, $i) || $i &gt;= $l;
}
#CP_ORDERS语法单元中的单条排序规则结束标记检查
function spa_end_order($t, $i, $l) {
    return spa_end_filter_self($t, $i, $l) || spa_end_orders($t, $i, $l);
}
#-----------------------------------------------语法分析-各个语法单元的读取
#将括号内容作为整体读取(这里主要做栈的处理)
function spa_read_bracket($t, &amp;$i, $l, $include_bracket = FALSE) {
    $tmp    = array();
    if ( $include_bracket )
        $tmp[]  = $t[$i];
    $i ++;
    $stack  = 0;
    while ( !spa_is_rbracket($t, $i) || $stack &gt; 0 ) {
        if ( spa_is_lbracket($t, $i) )
            $stack ++;
        else if ( spa_is_rbracket($t, $i) )
            $stack --;
        $tmp[]  = $t[$i ++];
    }
    if ( !spa_is_rbracket($t, $i) )
        sql_parser_error(__FILE__, __LINE__, __FUNCTION__);
    if ( $include_bracket )
        $tmp[]  = $t[$i];
    $i ++;
    return $tmp;
}
#读取SELECT关键字
function spa_read_select($t, &amp;$i, $l, &amp;$r) {
    if ( !spa_is_select($t, $i) )
        sql_parser_error(__FILE__, __LINE__, __FUNCTION__);
    $r[CP_SELECT]   = $t[$i ++];
}
#读取SELECT选项
function spa_read_options($t, &amp;$i, $l, &amp;$r) {
    while ( spa_is_option($t, $i) ) 
        $r[CP_OPTIONS][]    = $t[$i ++];
}
#读取查询字段
function spa_read_fields($t, &amp;$i, $l, &amp;$r) {
    while ( !spa_end_fields($t, $i, $l) ) {
        spa_read_field($t, $i, $l, $r);
        spa_read_field_separater($t, $i, $l, $r);
    }
    #SELECT语句至少需要一个查询字段
    if ( count($r[CP_FIELDS]) &lt; 1 ) 
        sql_parser_error(__FILE__, __LINE__, __FUNCTION__);
}
#读取单个查询字段
function spa_read_field($t, &amp;$i, $l, &amp;$r) {
    $tmp    = array();
    while ( !spa_end_field($t, $i, $l) ) 
        if ( spa_is_lbracket($t, $i) ) {
            $tmp    = array_merge($tmp, spa_read_bracket($t, $i, $l, TRUE));
        } else 
            $tmp[]  = $t[$i ++];
    $r[CP_FIELDS][] = $tmp;
}
#读取查询字段分隔符
function spa_read_field_separater($t, &amp;$i, $l, &amp;$r) {
    if ( spa_is_comma($t, $i, $n) ) {
        #$r[CP_FIELDS][]    = array_slice($t, $i, $n);
        $i  += $n;
    }
}
#读取哦FROM关键字
function spa_read_from($t, &amp;$i, $l, &amp;$r) {
    if ( spa_is_from($t, $i) )
        $r[CP_FROM] = $t[$i ++];
}
#读取要查询的表
function spa_read_tables($t, &amp;$i, $l, &amp;$r) {
    while ( !spa_end_tables($t, $i, $l) ) {
        $tmp    = array();
        spa_read_table_separater($t, $i, $l, $tmp);
        spa_read_table_name($t, $i, $l, $tmp);
        spa_read_table_alias($t, $i, $l, $tmp);
        spa_read_table_condition($t, $i, $l, $tmp);
        $r[CP_TABLES][] = $tmp;
    }
}
#读取表名
function spa_read_table_name($t, &amp;$i, $l, &amp;$r) {
    if ( spa_is_lbracket($t, $i) ) {
        $r[CPK_TABLES_TABLE]    = sql_analysis(spa_read_bracket($t, $i, $l));
    } else {
        $r[CPK_TABLES_TABLE]    = array($t[$i ++]);
        if ( spa_is_dot($t, $i) ) 
            array_push($r[CPK_TABLES_TABLE], $t[$i ++], $t[$i ++]);
    }
}
#读取表的别名
function spa_read_table_alias($t, &amp;$i, $l, &amp;$r) {
    if ( spa_is_as($t, $i) )
        $i ++;
    if ( !spa_is_on($t, $i) &amp;&amp; !spa_end_table($t, $i, $l) ) 
        $r[CPK_TABLES_ALIAS]    = $t[$i ++];
}
#读取表的连接条件
function spa_read_table_condition($t, &amp;$i, $l, &amp;$r) {
    if ( !spa_is_on($t, $i) ) return ;
    $i ++;
    while ( !spa_end_table($t, $i, $l) ) 
        if ( sp_is_lbracket($t, $i) )
            $r[CPK_TABLES_CONDITION]    = array_merge($r[CPK_TABLES_CONDITION], spa_read_bracket($t, $i, $l, TRUE));
        else 
            $r[CPK_TABLES_CONDITION][]  = $t[$i ++];
}
#读取表的连接符
function spa_read_table_separater($t, &amp;$i, $l, &amp;$r) {
    if ( spa_is_comma($t, $i, $n) || spa_is_join($t, $i, $n) ) {
        $r[CPK_TABLES_SEPARATER]    = array_slice($t, $i, $n);
        $i  += $n;
    }
}
#读取WHERE关键字
function spa_read_where($t, &amp;$i, $l, &amp;$r) {
    if ( spa_is_where($t, $i) )
        $r[CP_WHERE]    = $t[$i ++];
}
#读取查询条件(WHERE)
function spa_read_conditions($t, &amp;$i, $l, &amp;$r) {
    while ( !spa_end_conditions($t, $i, $l) ) {
        $tmp    = array();
        spa_read_condition($t, $i, $l, $tmp);
        $r[CP_CONDITIONS][] = $tmp;
    }
}
#读取单条查询条件(WHERE)
function spa_read_condition($t, &amp;$i, $l, &amp;$r) {
#TODO 对条件进行细节处理
    $tmp    = array();
    while( !spa_end_condition($t, $i, $l) ) 
        if ( spa_is_lbracket($t, $i) ) 
            $tmp    = array_merge($tmp, spa_read_bracket($t, $i, $l, TRUE));
        else 
            $tmp[]  = $t[$i ++];
    $r  = $tmp;
}
#读取GROUP BY关键字
function spa_read_group_by($t, &amp;$i, $l, &amp;$r) {
    if ( spa_is_group_by($t, $i) )
        $r[CP_GROUP_BY] = $t[$i ++] . SPACE . $t[$i ++];
}
#读取分组项
function spa_read_groups($t, &amp;$i, $l, &amp;$r) {
    while ( !spa_end_groups($t, $i, $l) ) {
        $tmp    = array();
        spa_read_group_field($t, $i, $l, $tmp);
        spa_read_group_order($t, $i, $l, $tmp);
        $r[CP_GROUPS][] = $tmp;
        spa_read_group_separater($t, $i, $l, $r[CP_GROUPS]);
    }
}
#读取单条分组项
function spa_read_group_field($t, &amp;$i, $l, &amp;$r) {
    $tmp    = array();
    while ( !spa_end_group($t, $i, $l) &amp;&amp; !spa_is_asc($t, $i) &amp;&amp; !spa_is_desc($t, $i) ) 
        if ( spa_is_lbracket($t, $i) ) 
            $tmp    = array_merge($tmp, spa_read_bracket($t, $i, $l, TRUE));
        else 
            array_push($tmp, $t[$i ++]);
    $r[CPK_GROUPS_FIELD]    = $tmp;
}
#读取分组项排序
function spa_read_group_order($t, &amp;$i, $l, &amp;$r) {
    if ( spa_is_desc($t, $i) || spa_is_asc($t, $i) )
        $r[CPK_GROUPS_ORDER]    = $t[$i ++];
}
#读取分组项分隔符
function spa_read_group_separater($t, &amp;$i, $l, &amp;$r) {
    if ( spa_is_comma($t, $i, $n) ) {
        #$r[]   = array_slice($t, $i, $n);
        $i      += $n;
    }
}
#读取HAVING关键字
function spa_read_having($t, &amp;$i, $l, &amp;$r) {
    if ( spa_is_having($t, $i) )
        $r[CP_HAVING]   = $t[$i ++];
}
#读取过滤条件(HAVING)
function spa_read_filters($t, &amp;$i, $l, &amp;$r) {
    while ( !spa_end_filters($t, $i, $l) ) {
        $tmp    = array();
        spa_read_filter($t, $i, $l, $tmp);
        $r[CP_FILTERS][]    = $tmp;
    }
}
function spa_read_filter($t, &amp;$i, $l, &amp;$r) {
#TODO 对条件进行细节处理
    $tmp    = array();
    while ( !spa_end_filter($t, $i, $l) )
        if ( spa_is_lbracket($t, $i) )
            $tmp    = array_merge($tmp, spa_read_bracket($t, $i, $l, TRUE));
        else 
            $tmp[]  = $t[$i ++];
    $r  = $tmp;
}
#读取ORDER BY关键字
function spa_read_order_by($t, &amp;$i, $l, &amp;$r) {
    if ( spa_is_order_by($t, $i) ) 
        $r[CP_ORDER_BY] = $t[$i ++] . SPACE . $t[$i ++];
}
#读取排序项
function spa_read_orders($t, &amp;$i, $l, &amp;$r) {
    while ( !spa_end_orders($t, $i, $l) ) {
        $tmp    = array();
        spa_read_order_field($t, $i, $l, $tmp);
        spa_read_order_order($t, $i, $l, $tmp);
        $r[CP_ORDERS][] =  $tmp;
        spa_read_order_separater($t, $i, $l, $r[CP_ORDERS]);
    }
}
#读取排序项字段
function spa_read_order_field($t, &amp;$i, $l, &amp;$r) {
    $tmp    = array();
    while ( !spa_end_order($t, $i, $l) &amp;&amp; !spa_is_asc($t, $i) &amp;&amp; !spa_is_desc($t, $i) ) 
        if ( spa_is_lbracket($t, $i) ) 
            $tmp    = array_merge($tmp, spa_read_bracket($t, $i, $l, TRUE));
        else
            array_push($tmp, $t[$i ++]);
    $r[CPK_ORDERS_FIELD]    = $tmp;
}
#读取排序项顺序
function spa_read_order_order($t, &amp;$i, $l, &amp;$r) {
    if ( spa_is_asc($t, $i) || spa_is_desc($t, $i) ) 
        $r[CPK_ORDERS_ORDER]    = $t[$i ++];
}
#读取排序项分隔符
function spa_read_order_separater($t, &amp;$i, $l, &amp;$r) {
    if ( spa_is_comma($t, $i, $n) ) {
        #$r[]   = array_slice($t, $i, $n);
        $i      += $n;
    }
}
#读取LIMIT关键字
function spa_read_limit($t, &amp;$i, $l, &amp;$r) {
    if ( spa_is_limit($t, $i, $l) )
        $r[CP_LIMIT]    = $t[$i ++];
}
#读取偏移参数
function spa_read_offset_count($t, &amp;$i, $l, &amp;$r) {
    $offset = 0;
    if ( spa_is_comma($t, $i + 1) ) {
        $offset = $t[$i];
        $i      += 2;
    }
    $count  = $t[$i ++];
    $r[CP_OFFSET]   = $offset;
    $r[CP_COUNT]    = $count;
}
#-------------------------------------------SQL还原
#递归的将$pieces所有子项按照顺序用$glue连接
function sr_recursive_implode($glue, $pieces) {
    if ( !is_array($pieces) ) return $pieces;
    foreach ( $pieces as &amp;$piece ) 
        if ( is_array($piece) )
            $piece  = sr_recursive_implode($glue, $piece);
    return implode_exclude_bracket($glue, $pieces);
}
function implode_exclude_bracket($glue, $pieces) {
    $ret    = &#39;&#39;;
    if ( is_array($pieces) ) {
        $tmp    = array();
        foreach ( $pieces as $piece ) {
            if ( $piece === LBRACKET || $piece === RBRACKET ) {
                $ret    .= implode($glue, $tmp) . $piece;
                $tmp    = array();
            } else {
                $tmp[]  = $piece;
            }
        }
        $ret    .= implode($glue, $tmp);
    }
    return $ret;
}
#检查给定数据$a是否非空数组, 如果指定了$k则检查$a[$k]
function is_no_empty_array($a, $k = NULL) {
    if ( !is_null($k) ) 
        if ( !array_key_exists($k, $a) ) return FALSE;
        else $a = $a[$k];
    return is_array($a) &amp;&amp; !empty($a);
}
function sr_restore_select($sc, &amp;$r) {
    if ( array_key_exists(CP_SELECT, $sc) ) 
        array_push($r, KW_SELECT);
}
#还原选项
function sr_restore_options($sc, &amp;$r) {
    if ( is_no_empty_array($sc, CP_OPTIONS) )
        array_push($r, sr_recursive_implode(SPACE, $sc[CP_OPTIONS]));
}
#还原查询字段
function sr_restore_fields($sc, &amp;$r) {
    if ( is_no_empty_array($sc, CP_FIELDS) ) {
        $tmp    = array();
        foreach ( $sc[CP_FIELDS] as $field ) 
            array_push($tmp, sr_recursive_implode(SPACE, $field));
        array_push($r, implode_exclude_bracket(COMMA, $tmp));
    }
}
#还原表
function sr_restore_tables($sc, &amp;$r) {
    if ( is_no_empty_array($sc, CP_TABLES) ) {
        $ret_arr    = array();
        foreach ( $sc[CP_TABLES] as $table ) {
            $tmp    = array();
            if ( array_key_exists(CPK_TABLES_SEPARATER, $table) )
                $tmp[]  = sr_recursive_implode(SPACE, $table[CPK_TABLES_SEPARATER]);
            if ( array_key_exists(CPK_TABLES_TABLE, $table) ) 
                if ( array_key_exists(CP_SELECT, $table[CPK_TABLES_TABLE]) )
                    $tmp[]  = LBRACKET . sql_restore($table[CPK_TABLES_TABLE]) . RBRACKET;
                else
                    $tmp[]  = sr_recursive_implode(SPACE, $table[CPK_TABLES_TABLE]);
            if ( array_key_exists(CPK_TABLES_ALIAS, $table) )
                $tmp[]  = KW_AS . SPACE . strval($table[CPK_TABLES_ALIAS]);
            if ( array_key_exists(CPK_TABLES_CONDITION, $table) )
                $tmp[]  = KW_ON . SPACE . sr_recursive_implode(SPACE, $table[CPK_TABLES_CONDITION]);
            $ret_arr[]  = implode_exclude_bracket(SPACE, $tmp);
        }
        array_push($r, KW_FROM . SPACE . implode_exclude_bracket(SPACE, $ret_arr));
    }
}
#还原条件
function sr_restore_conditions($sc, &amp;$r) {
    if ( is_no_empty_array($sc, CP_CONDITIONS) ) 
        array_push($r, KW_WHERE . SPACE . sr_recursive_implode(SPACE, $sc[CP_CONDITIONS]));
}
#还原分组项
function sr_restore_groups($sc, &amp;$r) {
    if ( is_no_empty_array($sc, CP_GROUPS) ) {
        $tmp    = array();
        foreach ( $sc[CP_GROUPS] as $group ) {
            $g  = sr_recursive_implode(SPACE, $group[CPK_GROUPS_FIELD]);
            if ( array_key_exists(CPK_GROUPS_ORDER, $group) )
                $g  .= SPACE . $group[CPK_GROUPS_ORDER];
            $tmp[]  = $g;
        }
        array_push($r, KW_GROUP_BY . SPACE . implode_exclude_bracket(COMMA, $tmp));
    }
}
#还原过滤条件
function sr_restore_filters($sc, &amp;$r) {
    if ( is_no_empty_array($sc, CP_FILTERS) ) 
        array_push($r, KW_HAVING . SPACE . sr_recursive_implode(SPACE, $sc[CP_FILTERS]));
}
#还原排序项
function sr_restore_orders($sc, &amp;$r) {
    if ( is_no_empty_array($sc, CP_ORDERS) ) {
        $tmp    = array();
        foreach ( $sc[CP_ORDERS] as $order ) {
            $o  = sr_recursive_implode(SPACE, $order[CPK_ORDERS_FIELD]);
            if ( array_key_exists(CPK_ORDERS_ORDER, $order) )
                $o  .= SPACE . $order[CPK_ORDERS_ORDER];
            $tmp[]  = $o;
        }
        array_push($r, KW_ORDER_BY . SPACE . implode_exclude_bracket(COMMA, $tmp));
    }
}
#还原偏移量
function sr_restore_offset_count($sc, &amp;$r) {
    if ( array_key_exists(CP_COUNT, $sc) ) {
        $count  = intval($sc[CP_COUNT]);
        $offset = intval(array_key_exists(CP_OFFSET, $sc) ? $sc[CP_OFFSET] : 0);
        array_push($r, KW_LIMIT . SPACE . $offset . COMMA . $count);
    }
}

#------------------------------------------------分页相关SQL重组子逻辑: sql_to_count相关
#将结构化SQL转换为计数的结构化SQL(不支持外连接)
function sc_to_count($sc, $alias = COUNT_DEFAULT_ALIAS) {
    #count字段构建
    $count_field    = sc_build_count_field($sc, $alias);
    #删除排序项
    sc_delete_orders($sc);
    #合并HAVING条件到WHERE
    $sc[CP_FIELDS]  = array($count_field);
    return $sc;
}
#构造count查询字段
function sc_build_count_field(&amp;$sc, $alias = COUNT_DEFAULT_ALIAS) {
    #构造count统计查询
    $count_field    = is_no_empty_array($sc, CP_GROUPS)
                    ? sc_build_count_by_group($sc)
                    : sc_build_count_normal($sc);
    #别名构建
    if ( !empty($alias) ) 
        array_push($count_field, KW_AS, $alias);
    return $count_field;
}
#根据分组构造count统计
function sc_build_count_by_group(&amp;$sc) {
    $count_field    = array(
        KW_COUNT . LBRACKET, 
        KW_DISTINCT, 
        tidy_fields_to_one(read_group_fields($sc)),
        RBRACKET, 
    );
    unset($sc[CP_GROUP_BY]);
    unset($sc[CP_GROUPS]);
    return $count_field;
}
#无分组的count构造
function sc_build_count_normal(&amp;$sc) {
    return array(
        KW_COUNT . LBRACKET, 
        &#39;*&#39;, 
        RBRACKET
    );
}
#删除排序相关项
function sc_delete_orders(&amp;$sc) {
    unset($sc[CP_ORDER_BY]);
    unset($sc[CP_ORDERS]);
}
#读取分组项中的字段信息
function read_group_fields($sc) {
    $tmp    = array();
    foreach ( $sc[CP_GROUPS] as $group ) 
        $tmp[]  = $group[CPK_GROUPS_FIELD];
    return $tmp;
}
#将多个字段信息整理成一个逗号分隔的大项(用于外层嵌套括号构成复杂字段)
function tidy_fields_to_one($fields) {
    $tmp    = array();
    foreach ( $fields as $field ) {
        array_push($tmp, $field);
        array_push($tmp, COMMA);
    }
    array_pop($tmp);
    return $tmp;
}

#------------------------------------------------分页相关SQL重组子逻辑: sql_add_since相关
#结构化SQL增加since_id
function sc_add_since(&amp;$sc, $prev_id, $next_id, &amp;$need_reverse) {
    $need_reverse   = FALSE;
    if ( is_null($prev_id) &amp;&amp; is_null($next_id) ) 
        return $sc;
    #将排序项拷贝到查询字段中, 修正排序项为新的查询字段的别名
    cp_orders_to_fields($sc);
    $need_prev  = !is_null($prev_id) &amp;&amp; !is_bool($prev_id);
    $need_next  = !is_null($next_id) &amp;&amp; !is_bool($next_id);
    #如果是向前查找, 需要对排序项进行逆序, 并对返回结果进行逆序
    if ( $need_prev &amp;&amp; !$need_next ) {
        sc_apply_since_id($sc, $prev_id, DIRECT_PREV);
        sc_orders_reverse($sc);
        $need_reverse   = TRUE;
    #如果是向后查找, 直接追加条件
    } else if ( !$need_prev &amp;&amp; $need_next ) {
        sc_apply_since_id($sc, $next_id, DIRECT_NEXT);
    #如果是闭区间查找, 则反向追加条件
    } else if ( $need_prev &amp;&amp; $need_next ) {
        sc_apply_since_id($sc, $prev_id, DIRECT_NEXT);
        sc_apply_since_id($sc, $next_id, DIRECT_PREV);
    }
    return $sc;
}
#将排序项复制到查询字段, 并自动设置别名, 使用别名作为排序项
function cp_orders_to_fields(&amp;$sc) {
    #读取排序项中的字段信息
    $o_fields   = read_order_fields($sc);
    #将排序项转换成查询字段格式
    $a_fields   = convert_orders_to_fields($sc, $o_fields, $n_o_fields);
    #将排序项转换而来的查询字段合并到原始查询字段
    sc_merge_having_to_where($sc);
    #将排序项字段合并到查询字段
    $sc[CP_FIELDS]  = array_merge($sc[CP_FIELDS], $a_fields);
    #设置新的排序项为别名
    $sc[CP_ORDERS]  = $n_o_fields;
}
#将id描述的规则按照方向direction应用到sc中
function sc_apply_since_id(&amp;$sc, $id, $direction) {
    $infos      = explain_since_id($id);
    if ( !array_key_exists(CP_FILTERS, $sc) ) {
        $sc[CP_HAVING]  = KW_HAVING;
        $sc[CP_FILTERS] = array();
    } else {
        array_unshift($sc[CP_FILTERS], LBRACKET);
        array_push($sc[CP_FILTERS], RBRACKET, KW_AND);
    }
    $filters    = id_info_to_filter($sc, $infos, $direction);
    array_unshift($filters, LBRACKET);
    array_push($filters, RBRACKET);
    sc_append_filter($sc, $filters);
}
#读取排序项中的字段信息
function read_order_fields($sc) {
    $tmp    = array();
    foreach ( $sc[CP_ORDERS] as $group ) 
        $tmp[]  = $group[CPK_ORDERS_FIELD];
    return $tmp;
}
#将排序项转换为查询字段格式, 并输出它们的别名的排序项数据
function convert_orders_to_fields($sc, $o_fields, &amp;$n_o_fields = NULL) {
    $tmp    = array();
    $i      = 0;
    $n_o_fields = array();
    foreach ( $o_fields as &amp;$o_field ) {
        $alias      = ORDER_ALIAS_PREFIX . $i;
        array_push($o_field, KW_AS, $alias);
        array_push($n_o_fields, array(
            CPK_ORDERS_FIELD    =&gt; array($alias), 
            CPK_ORDERS_ORDER    =&gt; array_key_exists(CPK_ORDERS_ORDER, $sc[CP_ORDERS][$i])
                                ? $sc[CP_ORDERS][$i][CPK_ORDERS_ORDER]
                                : KW_ASC, 
        ));
        $i ++;
    }
    return $o_fields;
}
#将HAVING条件合并到WHERE
function sc_merge_having_to_where(&amp;$sc) {
    if ( array_key_exists(CP_FILTERS, $sc) ) {
        $conditions = array();
        if ( array_key_exists(CP_CONDITIONS, $sc) ) {
            $conditions = $sc[CP_CONDITIONS];
            array_unshift($conditions, LBRACKET);
            array_push($conditions, RBRACKET);
        }
        array_push($conditions, KW_AND);
        array_push($conditions, LBRACKET);
        $conditions = array_merge($conditions, $sc[CP_FILTERS]);
        array_push($conditions, RBRACKET);
        $sc[CP_CONDITIONS]  = $conditions;
        unset($sc[CP_HAVING]);
        unset($sc[CP_FILTERS]);
    }
}
#将since_id还原为数组形式
function explain_since_id($id) {
    $tmp    = array();
    $items  = explode(SINCE_ID_SEPARATER_0, $id);
    foreach ( $items as $item ) {
        $item   = explode(SINCE_ID_SEPARATER_1, $item);
        $tmp[]  = array($item[0], $item[1]);
    }
    return $tmp;
}
#将since_id的数组描述转换为过滤条件
function id_info_to_filter($sc, $infos, $direction) {
    $tmp    = array();
    $i  = -1;
    $l  = count($infos);
    while ( ++ $i &lt; $l ) {
        $order  = find_order_from_orders($sc, $infos[$i][0]);
        $sign   = $direction === DIRECT_PREV
                ? (strtoupper($order) === KW_ASC ? KWS_LT : KWS_GT)
                : (strtoupper($order) === KW_ASC ? KWS_GT : KWS_LT);
        $t      = array();
        $j      = -1;
        while ( ++ $j &lt; $i ) 
            array_push($t, $infos[$j][0], KWS_EQ, $infos[$j][1], KW_AND);
        array_unshift($t, LBRACKET);
        array_push($t, $infos[$i][0], $sign, $infos[$i][1], RBRACKET, KW_OR);
        $tmp    = array_merge($tmp, $t);
    }
    array_pop($tmp);
    return $tmp;
}
#在结构化SQL中追加一些过滤条件
function sc_append_filter(&amp;$sc, $filters) {
    if ( empty($filters) ) return ;
    $sc[CP_HAVING]  = KW_HAVING;
    $original   = is_no_empty_array($sc, CP_FILTERS)
                ? $sc[CP_FILTERS]
                : array();
    $sc[CP_FILTERS] = array_merge($original, $filters);
}
#从结构化SQL的分组项中找到字段排序(TODO 这里的处理只适用于简单字段)
function find_order_from_orders($sc, $name) {
    foreach ( $sc[CP_ORDERS] as $o ) 
        if ( sr_recursive_implode(SPACE, $o[CPK_ORDERS_FIELD]) == $name ) 
            return array_key_exists(CPK_ORDERS_ORDER, $o) ? $o[CPK_ORDERS_ORDER] : KW_ASC;
    return KW_ASC;
}
#将结构化SQL中的所有ORDER项逆序
function sc_orders_reverse(&amp;$sc) {
    if ( is_no_empty_array($sc, CP_ORDERS) ) {
        foreach ( $sc[CP_ORDERS] as &amp;$item ) {
            if ( array_key_exists(CPK_ORDERS_ORDER, $item) &amp;&amp; strtoupper($item[CPK_ORDERS_ORDER]) === KW_DESC )
                $item[CPK_ORDERS_ORDER] = KW_ASC;
            else 
                $item[CPK_ORDERS_ORDER] = KW_DESC;
        }
    }
}

#------------------------------------------------分页相关SQL重组子逻辑: mysql_paginate_query相关
#修正偏移量值
function correct_offset($offset) {
    return is_numeric($offset) ? intval($offset) : 0;
}
#为结构化的SQL增加偏移量部分
function sc_add_offset(&amp;$sc, $offset, $count) {
    $sc[CP_LIMIT]   = KW_LIMIT;
    $sc[CP_OFFSET]  = $offset;
    $sc[CP_COUNT]   = $count;
    return $sc;
}
#使用结构化SQL和输出数据构造数据边界
function sc_datas_boundary($sc, &amp;$datas, &amp;$prev_id, &amp;$next_id) {
    $prev   = $datas[0];
    $next   = $datas[count($datas) - 1];
    $orders = orders_to_presentable($sc[CP_ORDERS]);
    $prev_id    = build_since_id($orders, $prev);
    $next_id    = build_since_id($orders, $next);
    delete_order_alias_datas($orders, $datas);
}
#将排序项转换为可读形式
function orders_to_presentable($orders) {
    $tmp    = array();
    foreach ( $orders as $order ) {
        $a  = sr_recursive_implode(SPACE, $order[CPK_ORDERS_FIELD]);
        $o  = array_key_exists(CPK_ORDERS_ORDER, $order)
            ? strtoupper($order[CPK_ORDERS_ORDER])
            : KW_ASC;
        $tmp[$a]    = $o;
    }
    return $tmp;
}
#根据排序项可视结构和数据项构造标识
function build_since_id($orders, $data) {
    $id = array();
    foreach ( $orders as $f =&gt; $o ) {
        if ( is_array($data) &amp;&amp; array_key_exists($f, $data) ) {
            $id[]   = $f . SINCE_ID_SEPARATER_1 . $data[$f];
        }
    }
    return implode(SINCE_ID_SEPARATER_0, $id);
}
#删除排序项增加上去的字段
function delete_order_alias_datas($orders, &amp;$datas) {
    foreach ( $orders as $f =&gt; $o ) 
        foreach ( $datas as &amp;$data ) 
            if ( array_key_exists($f, $data) ) unset($data[$f]);
}

#-------------------------------------------------数据库操作
#查询单条记录
function mysql_geta($conn, $sql) {
    $rs     = mysql_query($sql, $conn);
    if ( mysql_errno($conn) )
        mysql_error_handler(mysql_errno($conn), mysql_error($conn));
    $row    = mysql_fetch_array($rs, MYSQL_ASSOC);
    if ( mysql_errno($conn) )
        mysql_error_handler(mysql_errno($conn), mysql_error($conn));
    return $row;
}
#查询多条记录
function mysql_geta_all($conn, $sql) {
    $rs     = mysql_query($sql, $conn);
    if ( mysql_errno($conn) )
        mysql_error_handler(mysql_errno($conn), mysql_error($conn));
    $rows   = array();
    while ( $row = mysql_fetch_array($rs, MYSQL_ASSOC) )
        if ( mysql_errno($conn) )
            mysql_error_handler(mysql_errno($conn), mysql_error($conn));
        else
            array_push($rows, $row);
    return $rows;
}

</code></pre>

<p>test_base.php</p>

<pre lang="php"><code>&lt;?php
/*
 * 分页程序单元测试基础库
 * 1. 断言环境设置
 * 2. 定义mysql的错误处理
 * author: selfimpr
 * blog: http://blog.csdn.net/lgg201
 * mail: goosman.lei@gmail.com
 */
require dirname(__FILE__) . &#39;/page0.lib.php&#39;;
assert_options(ASSERT_ACTIVE, TRUE);
assert_options(ASSERT_WARNING, TRUE);
assert_options(ASSERT_CALLBACK, &#39;assert_handler&#39;);

function assert_info($file = NULL, $line = NULL, $sign = NULL) {
    static $msg;
    if ( func_num_args() &gt; 1 )
        $msg    = sprintf(chr(10) . &#39;assert error at %s[%s]: %s&#39;, $file, $line, $sign);
    else 
        return $msg;
}
function assert_handler() {
    echo assert_info();
}
function mysql_error_handler($errno, $errstr) {
    echo $errstr . chr(10);
}

</code></pre>

<p>test_convert.php</p>

<pre lang="php"><code>&lt;?php
/*
 * 分页程序 分页之间的转换测试
 * author: selfimpr
 * blog: http://blog.csdn.net/lgg201
 * mail: goosman.lei@gmail.com
 */
require dirname(__FILE__) . &#39;/test_base.php&#39;;
#ping_to_offset单元测试
function test_ping_to_offset() {
    $total_record   = 92;
    $count          = 10;
    $page_ping      = 3;
    $info           = ping_to_offset(-1, 1, $page_ping, $count, $total_record);
    assert(p_offset($info) === 0);
    $info           = ping_to_offset(3, 1, $page_ping, $count, $total_record);
    assert(p_offset($info) === 60);
    $info           = ping_to_offset(4, 1, $page_ping, $count, $total_record);
    assert(p_offset($info) === 90);
    $info           = ping_to_offset(5, 1, $page_ping, $count, $total_record);
    assert(p_offset($info) === 90);
    $info           = ping_to_offset(2, 3, $page_ping, $count, $total_record);
    assert(p_offset($info) === 50);
    $info           = ping_to_offset(4, 2, $page_ping, $count, $total_record);
    assert(p_offset($info) === 90);
}
#offset_to_ping单元测试
function test_offset_to_ping() {
    $page_ping  = 3;
    $count      = 10;
    $info       = offset_to_ping(0, $page_ping, $count);
    assert(p_page($info) === 1);
    assert(p_ping($info) === 1);
    $info       = offset_to_ping(10, $page_ping, $count);
    assert(p_page($info) === 1);
    assert(p_ping($info) === 2);
    $info       = offset_to_ping(20, $page_ping, $count);
    assert(p_page($info) === 1);
    assert(p_ping($info) === 3);
    $info       = offset_to_ping(30, $page_ping, $count);
    assert(p_page($info) === 2);
    assert(p_ping($info) === 1);
    $info       = offset_to_ping(40, $page_ping, $count);
    assert(p_page($info) === 2);
    assert(p_ping($info) === 2);
    $info       = offset_to_ping(50, $page_ping, $count);
    assert(p_page($info) === 2);
    assert(p_ping($info) === 3);
    $info       = offset_to_ping(60, $page_ping, $count);
    assert(p_page($info) === 3);
    assert(p_ping($info) === 1);
    $info       = offset_to_ping(70, $page_ping, $count);
    assert(p_page($info) === 3);
    assert(p_ping($info) === 2);
    $info       = offset_to_ping(90, $page_ping, $count);
    assert(p_page($info) === 4);
    assert(p_ping($info) === 1);
}
#page_to_offset单元测试
function test_page_to_offset() {
    $total_record   = 92;
    $count          = 10;
    $info           = page_to_offset(-1, $count, $total_record);
    assert(p_offset($info) === 0);
    $info           = page_to_offset(1, $count, $total_record);
    assert(p_offset($info) === 0);
    $info           = page_to_offset(3, $count, $total_record);
    assert(p_offset($info) === 20);
    $info           = page_to_offset(9, $count, $total_record);
    assert(p_offset($info) === 80);
    $info           = page_to_offset(10, $count, $total_record);
    assert(p_offset($info) === 90);
    $info           = page_to_offset(12, $count, $total_record);
    assert(p_offset($info) === 90);
}
#offset_to_page单元测试
function test_offset_to_page() {
    $count  = 10;
    $info   = offset_to_page(0, $count);
    assert(p_page($info) === 1);
    $info   = offset_to_page(30, $count);
    assert(p_page($info) === 4);
    $info   = offset_to_page(80, $count);
    assert(p_page($info) === 9);
    $info   = offset_to_page(90, $count);
    assert(p_page($info) === 10);
}

test_ping_to_offset();
test_offset_to_ping();
test_page_to_offset();
test_offset_to_page();

</code></pre>

<p>test_parse.php</p>

<pre lang="php"><code>&lt;?php
/*
 * 分页程序 SQL解析测试(由于处理简单, 可能会有某些SQL处理不了, 需要使用此工具先确认可用)
 * author: selfimpr
 * blog: http://blog.csdn.net/lgg201
 * mail: goosman.lei@gmail.com
 */
require dirname(__FILE__) . &#39;/test_base.php&#39;;

function test_sql_parser($sql) {
    $components = sql_parser($sql);
    echo &#39;测试SQL转换:&#39; . chr(10);
    echo sql_restore($components) . chr(10) . chr(10);
}
function test_sql_to_count($sql) {
    echo &#39;测试SQL附加COUNT:&#39; . chr(10);
    echo sql_to_count($sql) . chr(10) . chr(10);
}
function test_sql_add_since($sql, $prev_id = NULL, $next_id = NULL) {
    echo &#39;测试SQL附加since_id条件:&#39; . chr(10);
    echo sql_add_since($sql, $prev_id, $next_id, $need_reverse) . chr(10);
    if ( $need_reverse )
    echo &#39;只按照prev_id附加since_id时, 需要对查询结果逆序&#39; . chr(10);
    echo chr(10);
}

#样例SQL, 不关心语义正确性
$sql    = &#39;SELECT ALL HIGH_PRIORITY STRAIGHT_JOIN SQL_SMALL_RESULT SQL_BUFFER_RESULT SQL_CACHE SQL_CALC_FOUND_ROWS &#39;
        . &#39; if(a.feed_id &lt; 100, 100, 200) as t, f.feed_id d, f.content, `h`.`hot`, 3 + &quot;\&quot;\Hello FROM ,* &quot;, *, \&#39;world\&#39;&#39;
        . &#39; FROM feed AS f INNER JOIN comment c ON f.feed_id = c.feed_id AND (1 + (2 -1)) * 3 &gt; 4 LEFT JOIN (SELECT * FROM (SELECT * FROM hot) AS t) ON f.feed_id = h.feed_id, hot AS h1, hot h2, hot&#39;
        . &#39; WHERE 1 = 2 AND hot IS NOT NULL OR (1 &gt; 2 AND 3 &lt; 4)&#39;
        . &#39; GROUP by h.hot desc, f.feed_id, f.ctime ASc, (f.ctime + 1) + 3 desc&#39;
        . &#39; HAVING 1 = 2 AND 2 AND (feed.feed_id &lt; 5)&#39;
        . &#39; ORDER by hot desc, f.feed_id * (100 + 2) asC, c.comment_id desc&#39;
        . &#39; LIMIT 1, 3&#39;
        ;
if ( $argc &gt; 1 )
    $sql    = $argv[1];
test_sql_parser($sql);
test_sql_to_count($sql);
test_sql_add_since($sql, $argv[2] ? $argv[2] : &#39;__o_0:1948|__o_1:333333&#39;, $argv[3]);

echo &#39;原始SQL:&#39; . chr(10);
echo $sql . chr(10);

</code></pre>

<p>test_page.php</p>

<pre lang="php"><code>&lt;?php
/*
 * 分页程序 分页测试
 * author: selfimpr
 * blog: http://blog.csdn.net/lgg201
 * mail: goosman.lei@gmail.com
 */
require dirname(__FILE__) . &#39;/test_base.php&#39;;

#初始化数据量
define(&#39;FEED_ID_MIN&#39;,               1000);
define(&#39;FEED_COUNT&#39;,                972);
define(&#39;COMMENT_ID_MIN&#39;,            1000);
define(&#39;COMMENT_MAX_COUNT&#39;,         10);
define(&#39;HOT_MIN&#39;,                   1);
define(&#39;HOT_MAX&#39;,                   100);
define(&#39;TRANSPOND_COUNT_MAX&#39;,       100);

#数据库信息
$db_host    = &#39;127.0.0.1&#39;;
$db_port    = &#39;3306&#39;;
$db_user    = &#39;paginate_test&#39;;
$db_pass    = &#39;paginate_test&#39;;
$db_db      = &#39;paginate_test&#39;;
$db_charset = &#39;UTF-8&#39;;

#全局数据变量名
define(&#39;ALL_DATAS&#39;,                 &#39;_all_datas&#39;);

#涉及到的key
define(&#39;K_HC_FEEDS&#39;,                &#39;_hc_feed&#39;);
define(&#39;K_TC_FEEDS&#39;,                &#39;_tc_feed&#39;);
define(&#39;K_CC_FEEDS&#39;,                &#39;_cc_feed&#39;);
define(&#39;K_FEED_ID&#39;,                 &#39;feed_id&#39;);

#转发比较函数
function comp_transpond_count($a, $b) {
    $tc = $b[&#39;transpond_count&#39;] - $a[&#39;transpond_count&#39;];
    $ic = $b[&#39;feed_id&#39;] - $a[&#39;feed_id&#39;];
    return $tc != 0 ? $tc : $ic;
}
#评论比较函数
function comp_comment_count($a, $b) {
    $cc = $b[&#39;comment_count&#39;] - $a[&#39;comment_count&#39;];
    $ic = $b[&#39;feed_id&#39;] - $a[&#39;feed_id&#39;];
    return $cc != 0 ? $cc : $ic;
}
#热点比较函数
function comp_hot($a, $b) {
    $hc = $b[&#39;hot&#39;] - $a[&#39;hot&#39;];
    $ic = $b[&#39;feed_id&#39;] - $a[&#39;feed_id&#39;];
    return $hc != 0 ? $hc : $ic;
}

#数据库初始化临时文件
$tmp_file   = &#39;/tmp/__paginate_test_tmp.sql&#39;;
#数据库创建脚本
$db_init    = &lt;&lt;&lt;doc
DROP DATABASE IF EXISTS `paginate_test`;
CREATE DATABASE IF NOT EXISTS `paginate_test`;
USE `paginate_test`;

DROP TABLE IF EXISTS `feed`;
CREATE TABLE IF NOT EXISTS `feed` (
    `feed_id` INT NOT NULL PRIMARY KEY AUTO_INCREMENT COMMENT &#39;微博ID&#39;, 
    `ctime` INT NOT NULL COMMENT &#39;微博创建时间&#39;, 
    `content` CHAR(100) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;微博内容&#39;, 
    `transpond_count` INT NOT NULL DEFAULT 0 COMMENT &#39;微博转发数&#39;
) COMMENT &#39;微博表&#39;;

DROP TABLE IF EXISTS `comment`;
CREATE TABLE IF NOT EXISTS `comment` (
    `comment_id` INT NOT NULL PRIMARY KEY AUTO_INCREMENT COMMENT &#39;评论ID&#39;, 
    `content` CHAR(100) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;评论内容&#39;, 
    `feed_id` INT NOT NULL COMMENT &#39;被评论微博ID&#39;
) COMMENT &#39;评论表&#39;;

DROP TABLE IF EXISTS `hot`;
CREATE TABLE IF NOT EXISTS `hot` (
    `feed_id` INT NOT NULL PRIMARY KEY AUTO_INCREMENT COMMENT &#39;微博ID&#39;, 
    `hot` INT NOT NULL DEFAULT 0 COMMENT &#39;微博热度&#39;
) COMMENT &#39;热点微博表&#39;;
doc;

#初始化数据库
function init_db() {
    global $db_host, $db_port, $db_user, $db_pass, $db_db, $db_init, $tmp_file;
    $datas  = generate_data();
    file_put_contents($tmp_file, $db_init . chr(10) . data_to_sql($datas));
    `mysql -u$db_user -p$db_pass -h$db_host -P$db_port $db_db -e &#39;SOURCE $tmp_file&#39; &amp;&amp; rm $tmp_file`;
    $tc_datas   = $datas;
    $cc_datas   = $datas;
    $hc_datas   = $datas;
    foreach ( $cc_datas as $k =&gt; $v ) 
        if ( count($v[&#39;comments&#39;]) &lt;= 0 ) 
            unset($cc_datas[$k]);
    usort($tc_datas, &#39;comp_transpond_count&#39;);
    usort($cc_datas, &#39;comp_comment_count&#39;);
    usort($hc_datas, &#39;comp_hot&#39;);
    $GLOBALS[ALL_DATAS] = array(
        K_TC_FEEDS  =&gt; $tc_datas, 
        K_CC_FEEDS  =&gt; $cc_datas, 
        K_HC_FEEDS  =&gt; $hc_datas, 
    );
}
#生成测试数据
function generate_data() {
    $i      = -1;
    $j      = 0;
    $feeds  = array();
    while ( ++ $i &lt; FEED_COUNT ) {
        $feed_id            = FEED_ID_MIN + $i;
        $ctime              = time();
        $transpond_count    = rand(0, TRANSPOND_COUNT_MAX);
        $hot                = rand(HOT_MIN, HOT_MAX);
        $comments           = array();
        $comment_count      = rand(0, COMMENT_MAX_COUNT);
        $k                  = -1;
        while ( ++ $k &lt; $comment_count ) {
            $comment_id     = COMMENT_ID_MIN + $j ++;
            $comments[] = array(
                &#39;content&#39;       =&gt; sprintf(&#39;cid: %d, fid: %d, ccnt: %d, tcnt: %d, hot: %d&#39;, $comment_id, $feed_id, $comment_count, $transpond_count, $hot), 
                &#39;comment_id&#39;    =&gt; $comment_id, 
            );
        }
        $feeds[]    = array(
            &#39;feed_id&#39;           =&gt; $feed_id, 
            &#39;content&#39;           =&gt; sprintf(&#39;fid: %d, ccnt: %d, tcnt: %d, hot: %d&#39;, $feed_id, $comment_count, $transpond_count, $hot), 
            &#39;comments&#39;          =&gt; $comments, 
            &#39;comment_count&#39;     =&gt; $comment_count, 
            &#39;transpond_count&#39;   =&gt; $transpond_count, 
            &#39;hot&#39;               =&gt; $hot, 
            &#39;ctime&#39;             =&gt; $ctime, 
        );
    }
    return $feeds;
}
#将生成的测试数据转换为sql语句
function data_to_sql($feeds) {
    $feed_sql       = &#39;INSERT INTO feed(feed_id, ctime, content, transpond_count) VALUES &#39;;
    $comment_sql    = &#39;INSERT INTO comment(comment_id, content, feed_id) VALUES &#39;;
    $hot_sql        = &#39;INSERT INTO hot(feed_id, hot) VALUES &#39;;
    foreach ( $feeds AS $feed ) {
        $feed_sql   .= sprintf(&#39;(%d, %d, &quot;%s&quot;, %d), &#39;, $feed[&#39;feed_id&#39;], $feed[&#39;ctime&#39;], $feed[&#39;content&#39;], $feed[&#39;transpond_count&#39;]);
        if ( !empty($feed[&#39;comments&#39;]) )
            foreach ( $feed[&#39;comments&#39;] as $comment ) 
                $comment_sql    .= sprintf(&#39;(%d, &quot;%s&quot;, %d), &#39;, $comment[&#39;comment_id&#39;], $comment[&#39;content&#39;], $feed[&#39;feed_id&#39;]);
        $hot_sql    .= sprintf(&#39;(%d, %d), &#39;, $feed[&#39;feed_id&#39;], $feed[&#39;hot&#39;]);
    }
    return substr($feed_sql, 0, strlen($feed_sql) - 2) . &quot;;\n&quot; . substr($comment_sql, 0, strlen($comment_sql) - 2) .  &quot;;\n&quot; . substr($hot_sql, 0, strlen($hot_sql) - 2);
}
#格式化打印测试数据
function print_feeds($feeds) {
    foreach ( $feeds as $feed ) {
        printf(&quot;\tfeed_id: %d, transpond_count: %d, hot: %d, content: &#39;%s&#39;\n&quot;, $feed[&#39;feed_id&#39;], $feed[&#39;transpond_count&#39;], $feed[&#39;hot&#39;], $feed[&#39;content&#39;]);
        foreach ( $feed[&#39;comments&#39;] as $comment ) {
            printf(&quot;\t\tcomment_id: %d, content: &#39;%s&#39;\n&quot;, $comment[&#39;comment_id&#39;], $comment[&#39;content&#39;]);
        }
    }
}
#格式化打印所有测试数据
function print_all_feeds($all_feeds) {
    foreach ( $all_feeds as $key =&gt; $feeds ) {
        printf(&quot;order type: %s\n&quot;, $key);
        print_feeds($feeds);
        printf(&quot;\n\n&quot;);
    }
}
#基本断言函数
function assert_base($info, $datas, $offset, $count, $file, $line, $sign) {
    assert_info($file, $line, $sign . &#39;:count&#39;);
    assert(intval($count) === count(p_datas($info)));
    assert_info($file, $line, $sign . &#39;:datas&#39;);
    if ( is_array(p_datas($info)) )
    foreach ( p_datas($info) as $data ) 
        assert(intval($data[K_FEED_ID]) == intval($datas[$offset ++][K_FEED_ID]));
}
#断言热门数据
function assert_hot($info, $offset, $count, $file, $line) {
    assert_base($info, $GLOBALS[ALL_DATAS][K_HC_FEEDS], $offset, $count, $file, $line, __FUNCTION__);
}
#断言热转数据
function assert_transpond($info, $offset, $count, $file, $line) {
    assert_base($info, $GLOBALS[ALL_DATAS][K_TC_FEEDS], $offset, $count, $file, $line, __FUNCTION__);
}
#断言热评数据
function assert_comment($info, $offset, $count, $file, $line) {
    assert_base($info, $GLOBALS[ALL_DATAS][K_CC_FEEDS], $offset, $count, $file, $line, __FUNCTION__);
}

#初始化数据库连接
function init_conn() {
    global $db_host, $db_port, $db_user, $db_pass, $db_db, $db_charset;
    static $conn;
    if ( is_null($conn) ) {
        $conn   = mysql_connect($db_host . &#39;:&#39; . $db_port, $db_user, $db_pass);
        mysql_select_db($db_db, $conn);
        mysql_set_charset($db_charset, $conn);
    }
    return $conn;
}

#单纯传统分页测试
function test_tradition($sql, $assert, $total_record) {
    $total_page = ceil($total_record / 10);
    $remain     = $total_record % 10 ? $total_record % 10 : 10;
    $info   = mysql_paginate_tradition(init_conn(), $sql, -1, 10);
    $assert($info, 0, 10, __FILE__, __LINE__);
    $info   = mysql_paginate_tradition(init_conn(), $sql, 1, 10);
    $assert($info, 0, 10, __FILE__, __LINE__);
    $info   = mysql_paginate_tradition(init_conn(), $sql, 2, 10);
    $assert($info, 10, 10, __FILE__, __LINE__);
    $info   = mysql_paginate_tradition(init_conn(), $sql, 2, 10);
    $assert($info, 10, 10, __FILE__, __LINE__);
    $info   = mysql_paginate_tradition(init_conn(), $sql, $total_page - 1, 10);
    $assert($info, ($total_page - 2) * 10, 10, __FILE__, __LINE__);
    $info   = mysql_paginate_tradition(init_conn(), $sql, $total_page, 10);
    $assert($info, ($total_page - 1) * 10, $remain, __FILE__, __LINE__);
    $info   = mysql_paginate_tradition(init_conn(), $sql, $total_page + rand(1, 10), 10);
    $assert($info, ($total_page - 1) * 10, $remain, __FILE__, __LINE__);
}
#单纯分段分页测试
function test_ping($sql, $assert, $total_record) {
    $total_ping = ceil($total_record / 10);
    $total_page = ceil($total_ping / 3);
    $remain     = $total_record % 10 ? $total_record % 10 : 10;
    $remain_ping    = $total_ping % 3 ? $total_ping % 3 : 3;
    $info   = mysql_paginate_ping(init_conn(), $sql, -1, -1, 3, 10);
    $assert($info, 0, 10, __FILE__, __LINE__);
    $info   = mysql_paginate_ping(init_conn(), $sql, -1, 2, 3, 10);
    $assert($info, 10, 10, __FILE__, __LINE__);
    $info   = mysql_paginate_ping(init_conn(), $sql, 1, 3, 3, 10);
    $assert($info, 20, 10, __FILE__, __LINE__);
    $info   = mysql_paginate_ping(init_conn(), $sql, 1, 4, 3, 10);
    $assert($info, 20, 10, __FILE__, __LINE__);
    $info   = mysql_paginate_ping(init_conn(), $sql, 5, 2, 3, 10);
    $assert($info, 130, 10, __FILE__, __LINE__);
    $info   = mysql_paginate_ping(init_conn(), $sql, $total_page, $remain_ping, 3, 10);
    $assert($info, ($total_ping - 1) * 10, $remain, __FILE__, __LINE__);
    $info   = mysql_paginate_ping(init_conn(), $sql, $total_page + rand(1, 10), $remain_ping, 3, 10);
    $assert($info, ($total_ping - 1) * 10, $remain, __FILE__, __LINE__);
}
#单纯原始分页测试
function test_raw($sql, $assert, $total_record) {
    $remain     = $total_record % 10 ? $total_record % 10 : 10;
    $info   = mysql_paginate_raw(init_conn(), $sql, -1, 10);
    $assert($info, 0, 10, __FILE__, __LINE__);
    $info   = mysql_paginate_raw(init_conn(), $sql, 100, 10);
    $assert($info, 100, 10, __FILE__, __LINE__);
    $info   = mysql_paginate_raw(init_conn(), $sql, ($total_record - $remain), 10);
    $assert($info, ($total_record - $remain), $remain, __FILE__, __LINE__);
}
#单纯since_id分页测试
function test_since_id($sql, $assert) {
    #第一页
    $info_0 = mysql_paginate_since_id(init_conn(), $sql, 10);
    $assert($info_0, 0, 10, __FILE__, __LINE__);
    #无数据(第一页之前
    $info_1 = mysql_paginate_since_id(init_conn(), $sql, 10, p_prev_id($info_0));
    $assert($info_1, 0, 0, __FILE__, __LINE__);
    #第二页
    $info_2 = mysql_paginate_since_id(init_conn(), $sql, 10, NULL, p_next_id($info_0));
    $assert($info_2, 10, 10, __FILE__, __LINE__);
    #第三页
    $info_3 = mysql_paginate_since_id(init_conn(), $sql, 10, NULL, p_next_id($info_2));
    $assert($info_3, 20, 10, __FILE__, __LINE__);
    #第四页
    $info_4 = mysql_paginate_since_id(init_conn(), $sql, 10, NULL, p_next_id($info_3));
    $assert($info_4, 30, 10, __FILE__, __LINE__);
    #第三页
    $info_5 = mysql_paginate_since_id(init_conn(), $sql, 10, p_prev_id($info_4), NULL);
    $assert($info_5, 20, 10, __FILE__, __LINE__);
    #第二页(第二页至第三页之间的前10条)
    $info_5 = mysql_paginate_since_id(init_conn(), $sql, 10, p_next_id($info_0), p_prev_id($info_4));
    $assert($info_5, 10, 10, __FILE__, __LINE__);
}
#传统分页复合since_id分页测试
function test_tradition_since_id($sql, $assert, $total_record) {
    $total_page = ceil($total_record / 10);
    $remain     = $total_record % 10 ? $total_record % 10 : 10;
    $info   = mysql_paginate_tradition_since_id(init_conn(), $sql, -1, 10);
    $assert($info, 0, 10, __FILE__, __LINE__);
    $info   = mysql_paginate_tradition_since_id(init_conn(), $sql, 2, 10);
    $assert($info, 10, 10, __FILE__, __LINE__);
    $info   = mysql_paginate_tradition_since_id(init_conn(), $sql, $total_page - 1, 10);
    $assert($info, ($total_page - 2) * 10, 10, __FILE__, __LINE__);
    $info   = mysql_paginate_tradition_since_id(init_conn(), $sql, $total_page, 10);
    $assert($info, ($total_page - 1) * 10, $remain, __FILE__, __LINE__);
    #第一页
    $info_0 = mysql_paginate_tradition_since_id(init_conn(), $sql, 1, 10, TRUE, TRUE);
    $assert($info_0, 0, 10, __FILE__, __LINE__);
    #无数据(第一页之前)
    $info_1 = mysql_paginate_tradition_since_id(init_conn(), $sql, 1, 10, p_prev_id($info_0));
    $assert($info_1, 0, 0, __FILE__, __LINE__);
    #第二页
    $info_2 = mysql_paginate_tradition_since_id(init_conn(), $sql, 1, 10, NULL, p_next_id($info_0));
    $assert($info_2, 10, 10, __FILE__, __LINE__);
    #第三页
    $info_3 = mysql_paginate_tradition_since_id(init_conn(), $sql, 1, 10, NULL, p_next_id($info_2));
    $assert($info_3, 20, 10, __FILE__, __LINE__);
    #第二页
    $info_4 = mysql_paginate_tradition_since_id(init_conn(), $sql, 1, 10, p_prev_id($info_3));
    $assert($info_4, 10, 10, __FILE__, __LINE__);
    #第四页
    $info_5 = mysql_paginate_tradition_since_id(init_conn(), $sql, 1, 10, NULL, p_next_id($info_3));
    $assert($info_5, 30, 10, __FILE__, __LINE__);
    #第三页
    $info_6 = mysql_paginate_tradition_since_id(init_conn(), $sql, 2, 10, NULL, p_next_id($info_0));
    $assert($info_6, 20, 10, __FILE__, __LINE__);
    #第八页
    $info_7 = mysql_paginate_tradition_since_id(init_conn(), $sql, 7, 10, NULL, p_next_id($info_0));
    $assert($info_7, 70, 10, __FILE__, __LINE__);
    #最后一页
    $info_8 = mysql_paginate_tradition_since_id(init_conn(), $sql, $total_page - 1, 10, NULL, p_next_id($info_0));
    $assert($info_8, ($total_page - 1) * 10, $remain, __FILE__, __LINE__);
    #(TODO 分段分页/传统分页/原始分页与since_id分页联合使用时, 记录数是since_id条件附加之前的记录数, 因此会导致页码数据错乱, 目前不对此进行处理)
    #越界访问
    $info_8 = mysql_paginate_tradition_since_id(init_conn(), $sql, $total_page, 10, NULL, p_next_id($info_0));
    $assert($info_8, 0, 0, __FILE__, __LINE__);
}
#分段分页复合since_id分页测试
function test_ping_since_id($sql, $assert, $total_record) {
    $total_ping = ceil($total_record / 10);
    $total_page = ceil($total_ping / 3);
    $remain     = $total_record % 10 ? $total_record % 10 : 10;
    $remain_ping    = $total_ping % 3 ? $total_ping % 3 : 3;
    $info   = mysql_paginate_ping_since_id(init_conn(), $sql, -1, -1, 3, 10);
    $assert($info, 0, 10, __FILE__, __LINE__);
    $info   = mysql_paginate_ping_since_id(init_conn(), $sql, -1, 2, 3, 10);
    $assert($info, 10, 10, __FILE__, __LINE__);
    $info   = mysql_paginate_ping_since_id(init_conn(), $sql, 1, 3, 3, 10);
    $assert($info, 20, 10, __FILE__, __LINE__);
    $info   = mysql_paginate_ping_since_id(init_conn(), $sql, 1, 4, 3, 10);
    $assert($info, 20, 10, __FILE__, __LINE__);
    $info   = mysql_paginate_ping_since_id(init_conn(), $sql, 5, 2, 3, 10);
    $assert($info, 130, 10, __FILE__, __LINE__);
    $info   = mysql_paginate_ping_since_id(init_conn(), $sql, $total_page, $remain_ping, 3, 10);
    $assert($info, ($total_ping - 1) * 10, $remain, __FILE__, __LINE__);
    $info   = mysql_paginate_ping_since_id(init_conn(), $sql, $total_page + rand(1, 10), $remain_ping, 3, 10);
    $assert($info, ($total_ping - 1) * 10, $remain, __FILE__, __LINE__);
    #第一页第一段
    $info_0 = mysql_paginate_ping_since_id(init_conn(), $sql, 1, 1, 3, 10, TRUE, TRUE);
    $assert($info_0, 0, 10, __FILE__, __LINE__);
    #无数据(第一页之前)
    $info_1 = mysql_paginate_ping_since_id(init_conn(), $sql, 1, 1, 3, 10, p_prev_id($info_0));
    $assert($info_1, 0, 0, __FILE__, __LINE__);
    #第一页第二段
    $info_2 = mysql_paginate_ping_since_id(init_conn(), $sql, 1, 1, 3, 10, NULL, p_next_id($info_0));
    $assert($info_2, 10, 10, __FILE__, __LINE__);
    #第一页第三段
    $info_3 = mysql_paginate_ping_since_id(init_conn(), $sql, 1, 1, 3, 10, NULL, p_next_id($info_2));
    $assert($info_3, 20, 10, __FILE__, __LINE__);
    #第一页第二段
    $info_4 = mysql_paginate_ping_since_id(init_conn(), $sql, 1, 1, 3, 10, p_prev_id($info_3));
    $assert($info_4, 10, 10, __FILE__, __LINE__);
    #第一页第一段
    $info_5 = mysql_paginate_ping_since_id(init_conn(), $sql, 1, 1, 3, 10, NULL, p_next_id($info_3));
    $assert($info_5, 30, 10, __FILE__, __LINE__);
    #第一页第三段
    $info_6 = mysql_paginate_ping_since_id(init_conn(), $sql, 1, 2, 3, 10, NULL, p_next_id($info_0));
    $assert($info_6, 20, 10, __FILE__, __LINE__);
    #第七页第三段
    $info_7 = mysql_paginate_ping_since_id(init_conn(), $sql, 7, 2, 3, 10, NULL, p_next_id($info_0));
    $assert($info_7, 200, 10, __FILE__, __LINE__);
    #倒数第二页最后一段
    $info_9 = mysql_paginate_ping_since_id(init_conn(), $sql, $total_page - 1, 2, 3, 10, NULL, p_next_id($info_0));
    $assert($info_9, ($total_ping - $remain_ping - 1) * 10, 10, __FILE__, __LINE__);
    #(TODO 分段分页/传统分页/原始分页与since_id分页联合使用时, 记录数是since_id条件附加之前的记录数, 因此会导致页码数据错乱, 目前不对此进行处理)
    #越界访问
    $info_10    = mysql_paginate_ping_since_id(init_conn(), $sql, $total_page + rand(1, 10), 3, 3, 10, NULL, p_next_id($info_0));
    $assert($info_10, 0, 0, __FILE__, __LINE__);
}
#原始分页复合since_id分页测试
function test_raw_since_id($sql, $assert, $total_record) {
    $remain     = $total_record % 10 ? $total_record % 10 : 10;
    $info   = mysql_paginate_raw_since_id(init_conn(), $sql, -1, 10);
    $assert($info, 0, 10, __FILE__, __LINE__);
    $info   = mysql_paginate_raw_since_id(init_conn(), $sql, 100, 10);
    $assert($info, 100, 10, __FILE__, __LINE__);
    $info   = mysql_paginate_raw_since_id(init_conn(), $sql, $total_record - $remain, 10);
    $assert($info, $total_record - $remain, $remain, __FILE__, __LINE__);
    #第一页
    $info_0 = mysql_paginate_raw_since_id(init_conn(), $sql, 0, 10, TRUE, TRUE);
    $assert($info_0, 0, 10, __FILE__, __LINE__);
    #无数据(第一页之前)
    $info_1 = mysql_paginate_raw_since_id(init_conn(), $sql, 0, 10, p_prev_id($info_0));
    $assert($info_1, 0, 0, __FILE__, __LINE__);
    #第二页
    $info_2 = mysql_paginate_raw_since_id(init_conn(), $sql, 0, 10, NULL, p_next_id($info_0));
    $assert($info_2, 10, 10, __FILE__, __LINE__);
    #第三页
    $info_3 = mysql_paginate_raw_since_id(init_conn(), $sql, 0, 10, NULL, p_next_id($info_2));
    $assert($info_3, 20, 10, __FILE__, __LINE__);
    #第二页
    $info_4 = mysql_paginate_raw_since_id(init_conn(), $sql, 0, 10, p_prev_id($info_3));
    $assert($info_4, 10, 10, __FILE__, __LINE__);
    #第四页
    $info_5 = mysql_paginate_raw_since_id(init_conn(), $sql, 0, 10, NULL, p_next_id($info_3));
    $assert($info_5, 30, 10, __FILE__, __LINE__);
    #最后一页
    $info_6 = mysql_paginate_raw_since_id(init_conn(), $sql, $total_record - $remain - 10, 10, NULL, p_next_id($info_0));
    $assert($info_6, $total_record - $remain, $remain, __FILE__, __LINE__);
    #(TODO 分段分页/传统分页/原始分页与since_id分页联合使用时, 记录数是since_id条件附加之前的记录数, 因此会导致页码数据错乱, 目前不对此进行处理)
    #越界访问
    $info_7 = mysql_paginate_raw_since_id(init_conn(), $sql, 970, 10, NULL, p_next_id($info_0));
    $assert($info_7, 0, 0, __FILE__, __LINE__);
}

#初始化数据
init_db();

$h_sql  = &#39;SELECT f.feed_id, f.content, h.hot FROM feed AS f JOIN hot AS h ON f.feed_id = h.feed_id ORDER BY h.hot DESC, f.feed_id DESC&#39;;
$c_sql  = &#39;SELECT f.feed_id, f.content, COUNT(c.comment_id) AS count FROM feed AS f JOIN comment AS c ON f.feed_id = c.feed_id GROUP BY c.feed_id ORDER BY COUNT(c.comment_id) DESC, f.feed_id DESC&#39;;
$t_sql  = &#39;SELECT feed_id, content, transpond_count FROM feed ORDER BY transpond_count DESC, feed_id DESC&#39;;

$data_infos = array(
    array($c_sql, &#39;assert_comment&#39;, count($GLOBALS[ALL_DATAS][K_CC_FEEDS])), 
    array($h_sql, &#39;assert_hot&#39;, count($GLOBALS[ALL_DATAS][K_HC_FEEDS])), 
    array($t_sql, &#39;assert_transpond&#39;, count($GLOBALS[ALL_DATAS][K_TC_FEEDS])), 
);
$use_cases  = array(
    &#39;test_tradition&#39;, &#39;test_ping&#39;, &#39;test_raw&#39;, &#39;test_since_id&#39;, 
    &#39;test_tradition_since_id&#39;, &#39;test_ping_since_id&#39;, &#39;test_raw_since_id&#39;, 
);

foreach ( $data_infos as $data_info ) {
    foreach ( $use_cases as $use_case )
        call_user_func_array($use_case, $data_info);
}

</code></pre>

          </section>

          
        </article>
        <!-- END Main content -->
      </div>
    </main>


    <!-- Footer -->
    <footer class="site-footer">
      <div class="container">
        <a id="scroll-up" href="#"><i class="fa fa-angle-up"></i></a>

        <div class="row">
          <div class="col-md-6 col-sm-6">
            <p>Copyright &copy; 2016. All right reserved(京ICP备11026137号-2)</p>
          </div>
          <div class="col-md-6 col-sm-6">
<script language="javascript" type="text/javascript" src="http://js.users.51.la/18906058.js"></script>
<noscript><a href="http://www.51.la/?18906058" target="_blank"><img alt="&#x6211;&#x8981;&#x5566;&#x514D;&#x8D39;&#x7EDF;&#x8BA1;" src="http://img.users.51.la/18906058.asp" style="border:none" /></a></noscript>
          </div>
        </div>
      </div>
    </footer>
    <!-- END Footer -->

    <!-- Scripts -->
    <script src="http://static-cdn.tec-inf.com/js/theDocs.all.min.js"></script>
    <script src="http://static-cdn.tec-inf.com/js/theDocs.js"></script>
    <script src="http://static-cdn.tec-inf.com/js/custom.js"></script>

  </body>
</html>
